// scripts/contentWatcher.mjs
import { readdir, readFile, writeFile } from "node:fs/promises";
import { join, resolve, extname, basename } from "node:path";
import { fileURLToPath } from "node:url";
import { naturalSort } from "./sort-routes.mjs";
import { watch } from "node:fs";
import { generateTopicMappings } from "./generateTopicMappings.ts";
import { generateQualityMappings } from "./generateQualityMappings.ts";

const __dirname = fileURLToPath(new URL(".", import.meta.url));
const CONTENT_DIR = resolve(__dirname, "../content/en");
const OUTPUT_FILE = resolve(__dirname, "../utils/routes.ts");

const TOPICS_DIR = resolve(__dirname, "../pages/topic/_topics");

const QUALITIES_FILE = resolve(__dirname, "../data/qualities.json");

async function getFiles(dir) {
	const entries = await readdir(dir, { withFileTypes: true });
	const files = await Promise.all(
		entries.map(async (entry) => {
			const fullPath = join(dir, entry.name);

			// Skip hidden files/directories
			if (entry.name.startsWith(".")) return [];

			return entry.isDirectory() ? await getFiles(fullPath) : fullPath;
		})
	);
	return files.flat();
}

async function generateRoutes() {
	try {
		const files = await getFiles(CONTENT_DIR);

		// Process files to get base names without extensions
		const routes = files
			.filter((file) => extname(file).toLowerCase() === ".mdx")
			.map((file) => basename(file)) // Get just the filename
			.map((file) => file.replace(extname(file), "")); // Remove extension

		const sortedRoutes = naturalSort([...new Set(routes)]);

		const routesContent = `// Auto-generated by utils/generateRoutes.mjs
export const routes = ${JSON.stringify(sortedRoutes)};
`;

		await writeFile(OUTPUT_FILE, routesContent);
		console.log(`‚úÖ Generated ${routes.length} routes in ${OUTPUT_FILE}`);
	} catch (error) {
		console.error("‚ùå Route generation failed:", error);
		process.exit(1);
	}
}

async function watchContentDirectory() {
	console.log(`üëÄ Watching for changes in ${CONTENT_DIR}...`);

	watch(CONTENT_DIR, { recursive: true }, async (eventType, filename) => {
		console.log(
			`\nDetected ${eventType} on ${filename}. Regenerating routes...`
		);
		try {
			await generateRoutes();
		} catch (error) {
			console.error("‚ùå Route generation failed during watch:", error);
		}
	});

	// Watch topics directory
	watch(TOPICS_DIR, { recursive: true }, async (eventType, filename) => {
		if (
			filename &&
			(filename.endsWith(".yaml") || filename.endsWith(".yml"))
		) {
			console.log(
				`\nDetected ${eventType} on ${filename}. Regenerating topic mappings...`
			);
			try {
				await generateTopicMappings();
			} catch (error) {
				console.error(
					"‚ùå Topic mappings generation failed during watch:",
					error
				);
			}
		}
	});

	// Watch src/data/qualities.json for generating quality mappings
	watch(QUALITIES_FILE, async (eventType, filename) => {
		if (filename && filename.endsWith(".json")) {
			console.log(
				`\nDetected ${eventType} on ${filename}. Regenerating quality mappings...`
			);
			try {
				await generateQualityMappings();
			} catch (error) {
				console.error(
					"‚ùå Quality mappings generation failed during watch:",
					error
				);
			}
		}
	});
}

// Call generateRoutes initially to create the routes on startup
generateRoutes();

// Parse command line arguments
const args = process.argv.slice(2);
const shouldWatch = args.includes("--watch");

// Only watch if --watch flag is present
if (shouldWatch) {
	watchContentDirectory();
}
