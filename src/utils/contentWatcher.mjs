// scripts/contentWatcher.mjs
import { readdir, readFile, writeFile } from "node:fs/promises";
import { join, resolve, extname, basename } from "node:path";
import { fileURLToPath } from "node:url";
import { naturalSort } from "./sort-routes.mjs";
import { watch } from "node:fs";
import { generateTopicMappings } from "./generateTopicMappings.ts";
import { generateQualityMappings } from "./generateQualityMappings.ts";
import { incrementalUpdate as updateTranslationMemory } from "./generateTranslationMemory.ts";
import { incrementalSearchIndexUpdate } from "./generateSearchIndex.ts";
import { generateContentCounts } from "./addContentCounts.ts";

const __dirname = fileURLToPath(new URL(".", import.meta.url));
const CONTENT_DIR = resolve(__dirname, "../content/en");
const OUTPUT_FILE = resolve(__dirname, "../utils/routes.ts");

const TOPICS_DIR = resolve(__dirname, "../pages/topic/_topics");

const QUALITIES_FILE = resolve(__dirname, "../data/qualities.json");

async function getFiles(dir) {
	const entries = await readdir(dir, { withFileTypes: true });
	const files = await Promise.all(
		entries.map(async (entry) => {
			const fullPath = join(dir, entry.name);

			// Skip hidden files/directories
			if (entry.name.startsWith(".")) return [];

			return entry.isDirectory() ? await getFiles(fullPath) : fullPath;
		}),
	);
	return files.flat();
}

async function generateRoutes() {
	try {
		const files = await getFiles(CONTENT_DIR);

		// Process files to get base names without extensions
		const routes = files
			.filter((file) => extname(file).toLowerCase() === ".mdx")
			.map((file) => basename(file)) // Get just the filename
			.map((file) => file.replace(extname(file), "")); // Remove extension

		const sortedRoutes = naturalSort([...new Set(routes)]);

		const routesContent = `// Auto-generated by utils/generateRoutes.mjs
export const routes = ${JSON.stringify(sortedRoutes)};
`;

		await writeFile(OUTPUT_FILE, routesContent);
		console.log(`‚úÖ Generated ${routes.length} routes in ${OUTPUT_FILE}`);
	} catch (error) {
		console.error("‚ùå Route generation failed:", error);
		process.exit(1);
	}
}

async function watchContentDirectory() {
	console.log(`üëÄ Watching for changes in ${CONTENT_DIR}...`);
	let debounceTimer = null;
	let pendingEvent = null; // Track what kind of change happened

	/**
	 * Run generators appropriate to the type of change:
	 * - "rename" (file added/deleted): regenerate routes + counts + incremental TM
	 * - "change" (content edited): only incremental TM update for the changed file
	 */
	const runGenerators = async (eventType, changedFile) => {
		const absChangedFile = resolve(CONTENT_DIR, changedFile);

		if (eventType === "rename") {
			// File was added or deleted ‚Äî need to update routes, counts, search index, and TM
			try {
				console.log(
					"üöß Running generators: routes, counts, search index, translation memory...",
				);
				// Routes and counts must complete first (needed for collection pages)
				await Promise.all([
					generateRoutes().then(() =>
						console.log("   ‚Ä¢ routes.ts updated"),
					),
					generateContentCounts().then(() =>
						console.log(
							"   ‚Ä¢ directoryStructureWithCounts.ts updated",
						),
					),
				]);
				// Search index + TM run concurrently so files are written at ~same time
				await Promise.all([
					incrementalSearchIndexUpdate(absChangedFile).then(() =>
						console.log("   ‚Ä¢ searchIndex.ts updated"),
					),
					updateTranslationMemory(absChangedFile).then(() =>
						console.log("   ‚Ä¢ translationMemory.json updated"),
					),
				]);
				console.log("‚úÖ Generators complete");
			} catch (error) {
				console.error("‚ùå Generator run failed:", error);
			}
		} else {
			// Content edit ‚Äî update search index + TM concurrently
			// TM is in public/ so writing it won't trigger Vite re-render
			try {
				console.log(`üöß Incremental update for ${changedFile}...`);
				await Promise.all([
					incrementalSearchIndexUpdate(absChangedFile).then(() =>
						console.log("   ‚Ä¢ searchIndex.ts updated"),
					),
					updateTranslationMemory(absChangedFile).then(() =>
						console.log("   ‚Ä¢ translationMemory.json updated"),
					),
				]);
				console.log("‚úÖ Generators complete");
			} catch (error) {
				console.error("‚ùå Incremental update failed:", error);
			}
		}
	};

	watch(CONTENT_DIR, { recursive: true }, async (eventType, filename) => {
		if (!filename) return;
		// Only react to MDX content changes
		if (!filename.endsWith(".mdx")) return;
		console.log(
			`\nDetected ${eventType} on ${filename}. Scheduling regeneration...`,
		);
		// If a rename is pending, keep it (it's more expensive and includes everything)
		if (pendingEvent !== "rename") {
			pendingEvent = eventType;
		}
		if (debounceTimer) clearTimeout(debounceTimer);
		const capturedEvent = pendingEvent;
		const capturedFile = filename;
		debounceTimer = setTimeout(() => {
			pendingEvent = null;
			runGenerators(capturedEvent, capturedFile);
		}, 1000);
	});

	// Watch topics directory
	watch(TOPICS_DIR, { recursive: true }, async (eventType, filename) => {
		if (
			filename &&
			(filename.endsWith(".yaml") || filename.endsWith(".yml"))
		) {
			console.log(
				`\nDetected ${eventType} on ${filename}. Regenerating topic mappings...`,
			);
			try {
				await generateTopicMappings();
			} catch (error) {
				console.error(
					"‚ùå Topic mappings generation failed during watch:",
					error,
				);
			}
		}
	});

	// Watch src/data/qualities.json for generating quality mappings
	watch(QUALITIES_FILE, async (eventType, filename) => {
		if (filename && filename.endsWith(".json")) {
			console.log(
				`\nDetected ${eventType} on ${filename}. Regenerating quality mappings...`,
			);
			try {
				await generateQualityMappings();
			} catch (error) {
				console.error(
					"‚ùå Quality mappings generation failed during watch:",
					error,
				);
			}
		}
	});
}

// Call generateRoutes initially to create the routes on startup
generateRoutes();

// Parse command line arguments
const args = process.argv.slice(2);
const shouldWatch = args.includes("--watch");

// Only watch if --watch flag is present
if (shouldWatch) {
	watchContentDirectory();
}
