// scripts/contentWatcher.mjs
import { readdir, readFile, writeFile } from "node:fs/promises";
import { join, resolve, extname, basename } from "node:path";
import { fileURLToPath } from "node:url";
import { naturalSort } from "./sort-routes.mjs";
import { watch } from "node:fs";
import { generateTopicMappings } from "./generateTopicMappings.ts";
import { generateQualityMappings } from "./generateQualityMappings.ts";
import { exec as _exec } from "node:child_process";
import { promisify } from "node:util";

const exec = promisify(_exec);

const __dirname = fileURLToPath(new URL(".", import.meta.url));
const CONTENT_DIR = resolve(__dirname, "../content/en");
const OUTPUT_FILE = resolve(__dirname, "../utils/routes.ts");

const TOPICS_DIR = resolve(__dirname, "../pages/topic/_topics");

const QUALITIES_FILE = resolve(__dirname, "../data/qualities.json");

async function getFiles(dir) {
	const entries = await readdir(dir, { withFileTypes: true });
	const files = await Promise.all(
		entries.map(async (entry) => {
			const fullPath = join(dir, entry.name);

			// Skip hidden files/directories
			if (entry.name.startsWith(".")) return [];

			return entry.isDirectory() ? await getFiles(fullPath) : fullPath;
		})
	);
	return files.flat();
}

async function generateRoutes() {
	try {
		const files = await getFiles(CONTENT_DIR);

		// Process files to get base names without extensions
		const routes = files
			.filter((file) => extname(file).toLowerCase() === ".mdx")
			.map((file) => basename(file)) // Get just the filename
			.map((file) => file.replace(extname(file), "")); // Remove extension

		const sortedRoutes = naturalSort([...new Set(routes)]);

		const routesContent = `// Auto-generated by utils/generateRoutes.mjs
export const routes = ${JSON.stringify(sortedRoutes)};
`;

		await writeFile(OUTPUT_FILE, routesContent);
		console.log(`‚úÖ Generated ${routes.length} routes in ${OUTPUT_FILE}`);
	} catch (error) {
		console.error("‚ùå Route generation failed:", error);
		process.exit(1);
	}
}

async function watchContentDirectory() {
	console.log(`üëÄ Watching for changes in ${CONTENT_DIR}...`);
	let debounceTimer = null;
	const runGenerators = async () => {
		try {
			console.log(
				"üöß Running generators: routes, counts, search index..."
			);
			await generateRoutes();
			console.log("   ‚Ä¢ routes.ts updated");
			// Generate content counts (directoryStructureWithCounts.ts)
			await exec(
				`npx tsx ${resolve(__dirname, "./generateContentCounts.ts")}`
			);
			console.log("   ‚Ä¢ directoryStructureWithCounts.ts updated");
			// Regenerate search index used by collection discourses view
			await exec(
				`npx tsx ${resolve(__dirname, "./generateSearchIndex.ts")}`
			);
			console.log("   ‚Ä¢ searchIndex.ts updated");
			console.log("‚úÖ Generators complete");
		} catch (error) {
			console.error("‚ùå Generator run failed:", error?.stderr || error);
		}
	};

	watch(CONTENT_DIR, { recursive: true }, async (eventType, filename) => {
		if (!filename) return;
		// Only react to MDX content changes
		if (!filename.endsWith(".mdx")) return;
		console.log(
			`\nDetected ${eventType} on ${filename}. Scheduling regeneration...`
		);
		if (debounceTimer) clearTimeout(debounceTimer);
		debounceTimer = setTimeout(runGenerators, 200);
	});

	// Watch topics directory
	watch(TOPICS_DIR, { recursive: true }, async (eventType, filename) => {
		if (
			filename &&
			(filename.endsWith(".yaml") || filename.endsWith(".yml"))
		) {
			console.log(
				`\nDetected ${eventType} on ${filename}. Regenerating topic mappings...`
			);
			try {
				await generateTopicMappings();
			} catch (error) {
				console.error(
					"‚ùå Topic mappings generation failed during watch:",
					error
				);
			}
		}
	});

	// Watch src/data/qualities.json for generating quality mappings
	watch(QUALITIES_FILE, async (eventType, filename) => {
		if (filename && filename.endsWith(".json")) {
			console.log(
				`\nDetected ${eventType} on ${filename}. Regenerating quality mappings...`
			);
			try {
				await generateQualityMappings();
			} catch (error) {
				console.error(
					"‚ùå Quality mappings generation failed during watch:",
					error
				);
			}
		}
	});
}

// Call generateRoutes initially to create the routes on startup
generateRoutes();

// Parse command line arguments
const args = process.argv.slice(2);
const shouldWatch = args.includes("--watch");

// Only watch if --watch flag is present
if (shouldWatch) {
	watchContentDirectory();
}
