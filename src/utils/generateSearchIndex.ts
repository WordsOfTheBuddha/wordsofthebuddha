#!/usr/bin/env node

// Build-time generator for a client-usable search dataset (English only).
// Outputs:
// - src/data/searchIndex.ts (typed module for direct imports)

import { readFile, writeFile, mkdir } from "node:fs/promises";
import path from "node:path";
import { fileURLToPath } from "node:url";
import { glob } from "glob";
import matter from "gray-matter";

interface SearchDoc {
	slug: string;
	title: string;
	description?: string;
	content?: string;
	maxScore?: number; // Cap the maximum score for this doc (lower = appears lower in results)
	contentSearchable?: boolean; // If false, don't match on content or show content snippets
}

// Pages to exclude from search index (slugs without leading slash)
const BLACKLISTED_SLUGS = new Set([
	"index", // Home page
	"search", // Search page itself
	"signin", // Auth pages
	"register",
	"profile",
	"privacy", // Legal pages
	"public-domain",
	"review-room", // User-specific pages
	"sitemap.xml", // Technical pages
	"robots.txt",
]);

// Virtual pages that aren't MDX but should be searchable
// These are added manually with their metadata
const VIRTUAL_PAGES: SearchDoc[] = [
	{
		slug: "offline",
		title: "Offline Control Center",
		description:
			"Download suttas and collections for offline reading. Manage cached content and install the app.",
	},
];

// Pages where content should not be searched or shown in snippets
// (only title and description are used for matching)
const NO_CONTENT_SEARCH_SLUGS = new Set([
	"in-the-buddhas-words",
	"noble-truths-noble-path",
]);

// Keep content semantically intact but make paragraph boundaries consistent with Astro's body
function normalizeMdContent(md: string): string {
	if (!md) return "";
	// Normalize Windows/Mac newlines to LF and trim trailing spaces
	let s = md.replace(/\r\n?/g, "\n");
	s = s.replace(/[ \t]+$/gm, "");
	// Preserve tooltip syntax |text::tooltip| and blank lines
	return s;
}

async function main() {
	const start = Date.now();
	const __dirname = path.dirname(fileURLToPath(import.meta.url));
	const repoRoot = path.resolve(__dirname, "../..");
	const contentRoot = path.join(repoRoot, "src", "content", "en");
	const dataDir = path.join(repoRoot, "src", "data");
	const tsOutFile = path.join(dataDir, "searchIndex.ts");

	const patterns = ["**/*.mdx"]; // English content only
	const files = (
		await Promise.all(patterns.map((p) => glob(path.join(contentRoot, p))))
	).flat();

	console.log(
		`search-index: found ${
			files.length
		} English content files under ${path.relative(repoRoot, contentRoot)}`,
	);

	const docs: SearchDoc[] = [];

	for (const file of files) {
		try {
			const raw = await readFile(file, "utf8");
			const parsed = matter(raw);
			const data = parsed.data as Record<string, any>;
			const body = parsed.content || "";

			const slug =
				(data.slug as string) ||
				path.basename(file).replace(/\.[^.]+$/, "");
			const title = (data.title as string) || slug;
			const description = (data.description as string) || undefined;
			const content = normalizeMdContent(body);
			// If content shouldn't be searchable, set flag and clear content
			const contentSearchable = !NO_CONTENT_SEARCH_SLUGS.has(slug);

			// Skip empty or blacklisted entries
			if (!slug) continue;
			if (BLACKLISTED_SLUGS.has(slug)) {
				console.log(`search-index: skipping blacklisted slug: ${slug}`);
				continue;
			}
			docs.push({
				slug,
				title,
				description,
				content: contentSearchable ? content : "", // Empty content if not searchable
				contentSearchable: contentSearchable ? undefined : false, // Only set if false
			});
		} catch (e) {
			console.warn("[search-index] Skipping file due to error:", file, e);
		}
	}

	// Add virtual pages (non-MDX pages that should be searchable)
	for (const virtualPage of VIRTUAL_PAGES) {
		console.log(`search-index: adding virtual page: ${virtualPage.slug}`);
		docs.push(virtualPage);
	}

	await mkdir(dataDir, { recursive: true });
	console.log(`search-index: writing to ${tsOutFile}`);
	const json = JSON.stringify(docs);

	// Also emit a typed TS module for direct imports in server/client code
	const tsModule = `// Auto-generated by generateSearchIndex.ts. Do not edit.
// deno-lint-ignore-file
// eslint-disable
export type SearchDoc = { slug: string; title: string; description?: string; content: string; maxScore?: number; contentSearchable?: boolean };
const searchIndex: SearchDoc[] = ${json} as const;
export default searchIndex;
`;
	await writeFile(tsOutFile, tsModule, "utf8");

	const bytes = Buffer.byteLength(json, "utf8");
	const kb = bytes / 1024;
	const ms = Date.now() - start;
	console.log(
		`search-index: wrote ${docs.length} docs to TS module (${kb.toFixed(
			1,
		)} KB) in ${ms}ms`,
	);
}

main().catch((err) => {
	console.error("search-index generation failed:", err);
	process.exit(1);
});
