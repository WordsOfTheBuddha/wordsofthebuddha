#!/usr/bin/env node

// Build-time generator for a client-usable search dataset (English only).
// Outputs:
// - src/data/searchIndex.ts (typed module for direct imports)

import { readFile, writeFile, mkdir } from "node:fs/promises";
import path from "node:path";
import { fileURLToPath } from "node:url";
import { glob } from "glob";
import matter from "gray-matter";

interface SearchDoc {
	slug: string;
	title: string;
	description?: string;
	content: string;
	priority?: number;
}

// Pages to exclude from search index (slugs without leading slash)
const BLACKLISTED_SLUGS = new Set([
	"index", // Home page
	"search", // Search page itself
	"signin", // Auth pages
	"register",
	"profile",
	"privacy", // Legal pages
	"public-domain",
	"review-room", // User-specific pages
	"sitemap.xml", // Technical pages
	"robots.txt",
	"in-the-buddhas-words",
	"noble-truths-noble-path",
]);

// Keep content semantically intact but make paragraph boundaries consistent with Astro's body
function normalizeMdContent(md: string): string {
	if (!md) return "";
	// Normalize Windows/Mac newlines to LF and trim trailing spaces
	let s = md.replace(/\r\n?/g, "\n");
	s = s.replace(/[ \t]+$/gm, "");
	// Preserve tooltip syntax |text::tooltip| and blank lines
	return s;
}

async function main() {
	const start = Date.now();
	const __dirname = path.dirname(fileURLToPath(import.meta.url));
	const repoRoot = path.resolve(__dirname, "../..");
	const contentRoot = path.join(repoRoot, "src", "content", "en");
	const dataDir = path.join(repoRoot, "src", "data");
	const tsOutFile = path.join(dataDir, "searchIndex.ts");

	const patterns = ["**/*.mdx"]; // English content only
	const files = (
		await Promise.all(patterns.map((p) => glob(path.join(contentRoot, p))))
	).flat();

	console.log(
		`search-index: found ${
			files.length
		} English content files under ${path.relative(repoRoot, contentRoot)}`,
	);

	const docs: SearchDoc[] = [];

	for (const file of files) {
		try {
			const raw = await readFile(file, "utf8");
			const parsed = matter(raw);
			const data = parsed.data as Record<string, any>;
			const body = parsed.content || "";

			const slug =
				(data.slug as string) ||
				path.basename(file).replace(/\.[^.]+$/, "");
			const title = (data.title as string) || slug;
			const description = (data.description as string) || undefined;
			const content = normalizeMdContent(body);
			const priority =
				typeof data.priority === "number" ? data.priority : undefined;

			// Skip empty or blacklisted entries
			if (!slug) continue;
			if (BLACKLISTED_SLUGS.has(slug)) {
				console.log(`search-index: skipping blacklisted slug: ${slug}`);
				continue;
			}
			docs.push({ slug, title, description, content, priority });
		} catch (e) {
			console.warn("[search-index] Skipping file due to error:", file, e);
		}
	}

	await mkdir(dataDir, { recursive: true });
	console.log(`search-index: writing to ${tsOutFile}`);
	const json = JSON.stringify(docs);

	// Also emit a typed TS module for direct imports in server/client code
	const tsModule = `// Auto-generated by generateSearchIndex.ts. Do not edit.
// deno-lint-ignore-file
// eslint-disable
export type SearchDoc = { slug: string; title: string; description?: string; content: string; priority?: number };
const searchIndex: SearchDoc[] = ${json} as const;
export default searchIndex;
`;
	await writeFile(tsOutFile, tsModule, "utf8");

	const bytes = Buffer.byteLength(json, "utf8");
	const kb = bytes / 1024;
	const ms = Date.now() - start;
	console.log(
		`search-index: wrote ${docs.length} docs to TS module (${kb.toFixed(
			1,
		)} KB) in ${ms}ms`,
	);
}

main().catch((err) => {
	console.error("search-index generation failed:", err);
	process.exit(1);
});
