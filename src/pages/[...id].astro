---
export const prerender = false;

import { determineRouteType } from "../utils/routeHandler";
import CollectionLayout from "../layouts/CollectionLayout.astro";
import { getEntry } from "astro:content";
import { parseContent, createCombinedMarkdown } from "../utils/contentParser";
import { routes } from "../utils/routes";
import Layout from "../layouts/Layout.astro";
import { getLastModified } from "../utils/getLastModified";
import MDContent from "../components/MDContent.astro";
import { transformId } from "../utils/transformId";

// Helper function to check if a number is within a range
function isNumberInRange(num: number, rangeStr: string): boolean {
	const [start, end] = rangeStr.split("-").map(Number);
	return num >= start && num <= end;
}

// Helper function to compare hierarchical numbers
function compareHierarchicalNumbers(target: string, rangeStr: string): boolean {
	// Split numbers into their hierarchical parts
	const targetParts = target.split(".").map(Number);
	const [startStr, endStr] = rangeStr.split("-");

	// If no decimal points, do simple range comparison
	if (!target.includes(".") && !startStr.includes(".")) {
		return isNumberInRange(Number(target), rangeStr);
	}

	// Otherwise handle hierarchical numbers
	const startParts = startStr.split(".").map(Number);
	const endParts = endStr.split(".").map(Number);

	// For single-level numbers, just compare the main number
	if (targetParts.length === 1) {
		return targetParts[0] >= startParts[0] && targetParts[0] <= endParts[0];
	}

	// For hierarchical numbers, first compare the primary number
	if (targetParts[0] !== startParts[0]) return false;

	// Then check if secondary number is in range
	const secondaryNum = targetParts[1];
	const rangeStart = startParts[1] || 1;
	const rangeEnd = endParts[1] || endParts[0];
	return secondaryNum >= rangeStart && secondaryNum <= rangeEnd;
}

// Extract slug from params
const { id: originalId } = Astro.params;
let id = originalId;
const route = determineRouteType(id);
console.log("route type is: ", route.type, route.metadata);

// Initialize variables for different route types
let collectionProps;
let suttaProps;
let mainContent = "";
let sideContent;
const layout =
	(Astro.url.searchParams.get("layout") as "split" | "interleaved") ||
	"interleaved";

// Handle collection routes
if (route.type === "collection" && route.pattern) {
	const viewMode = Astro.url.searchParams.get("view") || "collections";
	collectionProps = {
		title: route.metadata?.title || "Collection",
		description: route.metadata?.description || "Collection of suttas",
		collection: viewMode === "collections",
		children: route.metadata?.children || {},
		searchPattern: route.pattern,
	};
} else {
	// Continue with existing sutta handling logic

	// Find current index in sorted routes or find containing route
	let currentIndex = routes.findIndex((route) => route === id);
	let sectionNumber;
	let fullRef;

	if (currentIndex === -1) {
		// Parse the ID to find potential parent route
		const match = id.match(/^([a-z]+)(\d+(?:\.\d+)?)/);
		if (match) {
			const [, prefix, num] = match;
			const targetNumber = parseFloat(num);
			sectionNumber = num;

			// Find a route that contains this number in its range
			const parentRoute = routes.find((route) => {
				if (!route.startsWith(prefix)) return false;
				const rangeMatch = route.match(
					/(\d+(?:\.\d+)?)-(\d+(?:\.\d+)?)$/
				);
				if (!rangeMatch) return false;
				return compareHierarchicalNumbers(num, rangeMatch[0]);
			});

			if (parentRoute) {
				currentIndex = routes.findIndex(
					(route) => route === parentRoute
				);
				id = parentRoute;
				fullRef = transformId(parentRoute);
				console.log(
					"matched route:",
					id,
					"for section:",
					sectionNumber,
					", full ref: ",
					fullRef
				);
			}
		}
	}

	if (currentIndex === -1) {
		return Astro.redirect(`/search?q=${id}`);
	}

	// Get showPali from query string
	const showPali = Astro.url.searchParams.get("pli") === "true";
	console.log("page: ", id, "showPali: ", showPali);

	// Load content
	const contentItem = await getEntry("all", id);
	if (!contentItem) {
		console.warn("English content not found");
		console.groupEnd();
		return Astro.redirect(`/search?q=${id}`);
	}

	// Always parse content through contentParser
	let paliContent = { body: "" };
	if (showPali) {
		const paliEntry = await getEntry("pliAll", id);
		if (paliEntry) {
			paliContent = paliEntry;
		}
	}

	// Parse and combine content
	const pairs = await parseContent(
		paliContent,
		contentItem,
		sectionNumber,
		fullRef
	);
	const content = createCombinedMarkdown(pairs, showPali, layout);

	// Prepare content based on layout type
	if (typeof content === "string") {
		mainContent = content;
	} else {
		mainContent = content.english;
		sideContent = content.pali;
	}

	// Extract last two segments of file path and remove extension
	const fpParts = (contentItem.filePath ?? "").split("/");
	let folder = fpParts[fpParts.length - 2] || "";
	const fp = folder ? `${folder}/${id}` : id;

	// Find next and previous items
	const nextIndex = currentIndex + 1;
	const prevIndex = currentIndex - 1;
	const next =
		nextIndex < routes.length
			? await getEntry("all", routes[nextIndex])
			: null;
	const prev =
		prevIndex >= 0 ? await getEntry("all", routes[prevIndex]) : null;

	// Get the file's last modified time
	const filePath = contentItem.filePath || "";
	const lastUpdated = getLastModified(filePath);

	suttaProps = {
		fp,
		title: contentItem.data.title,
		description: contentItem.data.description,
		qualities: contentItem.data.qualities
			?.split(",")
			.map((tag: string) => tag.trim()),
		prev,
		next,
		id,
		showReadLater: true,
		showSave: true,
		showRead: true,
		lastUpdated,
		showAuth: true,
		showPali: true,
	};
}
---

{
	route.type === "collection" ? (
		<CollectionLayout
			title={route.metadata?.title || ""}
			description={route.metadata?.description || ""}
			collection
			children={route.metadata?.children || {}}
			searchPattern={route.pattern || ""}
		/>
	) : (
		<Layout {...suttaProps}>
			<MDContent
				content={mainContent}
				sideContent={sideContent}
				layout={layout}
			/>
		</Layout>
	)
}
