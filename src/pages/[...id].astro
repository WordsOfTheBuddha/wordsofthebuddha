---
// Catch-all stays SSR to support partial paragraph routes
export const prerender = false;
import { getEntry } from "astro:content";
import {
	parseContent,
	createCombinedMarkdown,
	compareHierarchicalNumber,
	constructHierarchicalEnd,
	isValidParagraphRange,
	debug,
} from "../utils/contentParser";
import { routes } from "../utils/routes";
import { directoryStructure } from "../data/directoryStructure";
import Layout from "../layouts/Layout.astro";
import { getLastModified } from "../utils/getLastModified";
import MDContent from "../components/MDContent.astro";
import { transformId } from "../utils/transformId";

// Extract slug from params (may contain slashes because this is a rest parameter)
const { id: originalId } = Astro.params;
let id: string = originalId || "";

// Support legacy / nested style paths like /iti/iti50-99 or /ud/ud8/ud8.2 by redirecting
// to the canonical top-level discourse slug (last segment) if it exists.
if (originalId && originalId.includes("/")) {
	const segments = originalId.split("/").filter(Boolean);
	if (segments.length > 1) {
		const candidate = segments[segments.length - 1];

		// Collect collection slugs (same logic as [collection].astro)
		const collectionSlugs: string[] = [];
		const walk = (map: Record<string, any>) => {
			for (const key of Object.keys(map)) {
				collectionSlugs.push(key);
				const child = map[key]?.children;
				if (child && typeof child === "object") walk(child);
			}
		};
		walk(directoryStructure);
		const isCollection = collectionSlugs.includes(candidate);
		const isDiscourse = routes.includes(candidate);

		if (isCollection || isDiscourse) {
			if (originalId !== candidate) {
				const location = `/${candidate}`;
				return new Response(null, {
					status: 301,
					headers: { Location: location },
				});
			}
		}
	}
}

// Filter out system/browser and asset-like requests early to avoid hijacking dev/build assets
const SYSTEM_REQUEST_PATTERNS = [
	".well-known",
	"favicon.ico",
	"robots.txt",
	"sitemap.xml",
	"apple-touch-icon",
	"chrome-extension",
	"__webpack",
	"_next",
	"@vite",
	"@fs",
];

const ASSET_EXT_REGEX =
	/\.(?:js|css|json|png|jpg|jpeg|svg|ico|gif|webp|avif|woff2?|ttf|otf|map|xml|webmanifest)$/i;

const isSystemRequest =
	!id ||
	SYSTEM_REQUEST_PATTERNS.some((pattern) => originalId?.includes(pattern)) ||
	// Typical asset requests by extension (including nested ones we did not redirect above)
	ASSET_EXT_REGEX.test(originalId ?? "");

if (isSystemRequest) {
	return new Response(null, { status: 404 });
}

console.log("requesting page:", id);

// Dynamic route only handles discourses; collections are handled by src/pages/[collection].astro

// Initialize variables for different route types
let collectionProps;
let suttaProps;
let mainContent = "";
let sideContent;
let splitEnglish: string | undefined = undefined;
let splitPali: string | undefined = undefined;
// Server should not decide layout; default to interleaved for prerender/SSR.
// Client (Layout.astro) handles layout toggling and URL cleanup.
const layout: "split" | "interleaved" = "interleaved";

{
	// Continue with existing sutta handling logic

	// Find current index in sorted routes or find containing route
	let currentIndex = routes.findIndex((route) => route === id);
	let sectionNumber;
	let fullRef;
	let paragraphRequest: {
		type: "single" | "range";
		start: number;
		end?: number;
	} | null = null;
	let baseDiscourseId = id;
	let discourseRange: { start: string; end: string } | null = null;

	// Helper function to check if a range contains another range
	function rangeContainsRange(
		parentRange: string,
		targetRange: string
	): boolean {
		const [parentStart, parentEnd] = parentRange.split("-");
		const [targetStart, targetEnd] = targetRange.split("-");

		// Debug logging in development only
		debug(
			`Checking if parent range ${parentRange} contains target range ${targetRange}`
		);
		debug(
			`Parent: ${parentStart} to ${parentEnd}, Target: ${targetStart} to ${targetEnd}`
		);

		// Use hierarchical comparison instead of parseFloat
		const targetStartInRange =
			compareHierarchicalNumber(targetStart, parentStart) >= 0;
		const targetEndInRange =
			compareHierarchicalNumber(targetEnd, parentEnd) <= 0;

		debug(
			`targetStartInRange: ${targetStartInRange}, targetEndInRange: ${targetEndInRange}`
		);

		return targetStartInRange && targetEndInRange;
	}

	if (currentIndex === -1) {
		// Parse the ID to find potential parent route OR paragraph request
		// First, try to parse the full ID more carefully
		debug(`Full ID parsing for: ${id}`);

		// Check if this looks like a paragraph range (ends with .X or .X-Y)
		const paragraphRangeMatch = id.match(/^(.+)\.(\d+(?:-\d+)?)$/);
		if (paragraphRangeMatch) {
			const [, baseId, paragraphPart] = paragraphRangeMatch;
			debug(
				`Detected potential paragraph range - baseId: ${baseId}, paragraphPart: ${paragraphPart}`
			);

			// Check if the baseId exists as a discourse
			const baseContent = await getEntry("all", baseId);
			if (baseContent) {
				debug(
					`Found baseContent for ${baseId} - treating as paragraph range`
				);
				// Parse the paragraph part
				if (paragraphPart.includes("-")) {
					const [start, end] = paragraphPart.split("-").map(Number);
					if (isValidParagraphRange(start, end)) {
						paragraphRequest = { type: "range", start, end };
						baseDiscourseId = baseId;
						id = baseId;
						currentIndex = routes.findIndex(
							(route) => route === baseId
						);
						fullRef = transformId(baseId);
						debug(
							`Set up paragraph range: ${start}-${end} for ${baseId}`
						);
					}
				} else {
					const paragraphNum = Number(paragraphPart);
					if (!isNaN(paragraphNum)) {
						paragraphRequest = {
							type: "single",
							start: paragraphNum,
						};
						baseDiscourseId = baseId;
						id = baseId;
						currentIndex = routes.findIndex(
							(route) => route === baseId
						);
						fullRef = transformId(baseId);
						debug(
							`Set up single paragraph: ${paragraphNum} for ${baseId}`
						);
					}
				}
			} else {
				debug(
					`No baseContent found for ${baseId} - not a paragraph range`
				);
			}
		}

		// If still no match, try the original discourse range logic
		if (currentIndex === -1) {
			debug(`No paragraph range match, trying discourse range logic`);
			const idParseMatch = id.match(/^([a-z]+)(\d+(?:\.\d+)?(?:-\d+)?)/);
			debug(`Discourse range parsing - id: ${id}, match:`, idParseMatch);
			if (idParseMatch) {
				const [, prefix, numericPart] = idParseMatch;
				debug(
					`Parsed for discourse range - prefix: ${prefix}, numericPart: ${numericPart}`
				);

				// Check for discourse ranges
				if (numericPart.includes("-")) {
					const [startStr, endStr] = numericPart.split("-");
					debug(
						`Found range in numericPart: ${startStr} to ${endStr}`
					);

					// Find a route that contains this range
					const parentRoute = routes.find((route) => {
						if (!route.startsWith(prefix)) return false;

						const rangeMatch = route.match(
							/(\d+(?:\.\d+)?)-(\d+(?:\.\d+)?)$/
						);

						if (!rangeMatch) return false;

						// Check if the route's range contains our target range
						const routeRangeStr = rangeMatch[0];
						const targetRangeStr = `${startStr}-${endStr}`;
						const contains = rangeContainsRange(
							routeRangeStr,
							targetRangeStr
						);

						return contains;
					});

					if (parentRoute) {
						debug(
							`Found parent route for discourse range: ${parentRoute}`
						);
						currentIndex = routes.findIndex(
							(route) => route === parentRoute
						);
						id = parentRoute;
						fullRef = transformId(parentRoute);
						// Set up discourse range for content parsing
						// Construct the proper end value with full hierarchical structure
						const constructedEnd = constructHierarchicalEnd(
							startStr,
							endStr
						);
						discourseRange = {
							start: startStr,
							end: constructedEnd,
						};
						debug(`Set up discourse range:`, discourseRange);
					} else {
						debug(`No parent route found for discourse range`);
					}
				} else {
					debug(
						`No range found, checking for single discourse section`
					);
					// Single discourse section (existing logic)
					sectionNumber = numericPart;

					// Find a route that contains this number in its range
					const parentRoute = routes.find((route) => {
						if (!route.startsWith(prefix)) return false;

						const rangeMatch = route.match(
							/(\d+(?:\.\d+)?)-(\d+(?:\.\d+)?)$/
						);

						if (!rangeMatch) return false;

						// Proper range checking - compare against start and end bounds
						const [, rangeStart, rangeEnd] = rangeMatch;

						// Construct the proper end value (e.g., "17.13-20" becomes "17.13" to "17.20")
						const properRangeEnd = constructHierarchicalEnd(
							rangeStart,
							rangeEnd
						);

						const isInRange =
							compareHierarchicalNumber(
								numericPart,
								rangeStart
							) >= 0 &&
							compareHierarchicalNumber(
								numericPart,
								properRangeEnd
							) <= 0;

						return isInRange;
					});

					if (parentRoute) {
						debug(
							`Found parent route for single section: ${parentRoute}`
						);
						currentIndex = routes.findIndex(
							(route) => route === parentRoute
						);
						id = parentRoute;
						fullRef = transformId(parentRoute);
					} else {
						debug(`No parent route found for single section`);
					}
				}
			}
		}
	}

	if (currentIndex === -1) {
		debug("No matching route found for:", id);
		// Encode potential non-ASCII characters to avoid invalid Location header values
		return Astro.redirect(`/search?q=${encodeURIComponent(id)}`);
	}

	// Load content with fresh file system read in development
	let contentItem = await getEntry("all", id);

	if (!contentItem) {
		console.warn("English content not found");
		console.groupEnd();
		// Encode potential non-ASCII characters to avoid invalid Location header values
		return Astro.redirect(`/search?q=${encodeURIComponent(id)}`);
	}

	// Always parse content through contentParser
	// Always include Pali content so client can toggle without server roundtrips
	let paliContent = { body: "" } as any;
	{
		const paliEntry = await getEntry("pliAll", id);
		if (paliEntry) paliContent = paliEntry;
	}

	// Parse and combine content
	const pairs = await parseContent(
		paliContent,
		contentItem,
		!paragraphRequest && !discourseRange ? sectionNumber : undefined,
		fullRef,
		paragraphRequest,
		discourseRange
	);

	// Generate both interleaved and split variants; client toggles via html classes
	const interleavedContent = createCombinedMarkdown(
		pairs,
		true,
		"interleaved",
		paragraphRequest
	);
	const splitContent = createCombinedMarkdown(
		pairs,
		true,
		"split",
		paragraphRequest
	);

	if (typeof interleavedContent === "string") {
		mainContent = interleavedContent;
	}
	if (typeof splitContent !== "string") {
		splitEnglish = splitContent.english;
		splitPali = splitContent.pali;
	}

	// Extract last two segments of file path and remove extension
	const fpParts = (contentItem.filePath ?? "").split("/");
	let folder = fpParts[fpParts.length - 2] || "";
	const fp = folder ? `${folder}/${id}` : id;

	// Find next and previous items
	const nextIndex = currentIndex + 1;
	const prevIndex = currentIndex - 1;
	const next =
		nextIndex < routes.length
			? await getEntry("all", routes[nextIndex])
			: null;
	const prev =
		prevIndex >= 0 ? await getEntry("all", routes[prevIndex]) : null;

	// Get the file's last modified time
	const filePath = contentItem.filePath || "";
	const lastUpdated = getLastModified(filePath);

	suttaProps = {
		fp,
		title: contentItem.data.title,
		description: contentItem.data.description,
		qualities: contentItem.data.qualities
			?.split(",")
			.map((tag: string) => tag.trim()),
		prev,
		next,
		id,
		showReadLater: true,
		showSave: true,
		showRead: true,
		lastUpdated,
		showAuth: true,
		showPali: true,
		paragraphRequest,
		commentary: contentItem.data.commentary,
	};
}
---

<Layout {...suttaProps}>
	<MDContent
		content={mainContent}
		splitEnglish={splitEnglish}
		splitPali={splitPali}
	/>
</Layout>
