---
export const prerender = false;
import Layout from "../../layouts/Layout.astro";
import Funnel from "../../assets/funnel.svg?raw";
import "../../styles/discover.css";
import ProjectStatus from "src/components/ProjectStatus.astro";

const seoTitle = "Discover the Words of the Buddha";
const description = "Explore by topics";

// Generate alphabet for A-Z navigation
const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
---

<Layout seoTitle={seoTitle} showAuth={true}>
	<main class="container mx-auto p-4 pt-0">
		<div class="mb-8">
			<p class="text-gray-600 dark:text-gray-400 mb-6">
				{seoTitle}
			</p>

			<ProjectStatus />

			<p class="text-gray-600 dark:text-gray-400 mt-6 mb-4">
				{description}
			</p>
			<!-- Sticky Filter Controls -->
			<div
				id="filter-controls"
				class="sticky top-0 bg-gray-50 dark:bg-gray-800 z-10 mb-6 bg-gray-50 dark:bg-gray-800 rounded-lg transition-all duration-300"
			>
				<!-- Collapsed State - Mobile Only -->
				<div
					id="filter-collapsed"
					class="hidden md:hidden bg-gray-50 dark:bg-gray-800 rounded-lg p-3 shadow-sm"
				>
					<div class="flex items-center justify-between">
						<div class="flex items-center gap-2">
							<div
								class="w-4 h-4 text-gray-600 dark:text-gray-400"
							>
								<Fragment set:html={Funnel} />
							</div>
							<span
								class="text-sm font-medium text-gray-700 dark:text-gray-300"
							>
								Filters
							</span>
							<span
								id="active-filters-count"
								class="text-xs bg-[var(--primary-color)] text-white px-2 py-1 rounded-full"
							>
								2
							</span>
						</div>
						<button
							id="expand-filters-btn"
							class="p-2 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-700 transition-colors"
							aria-label="Expand filters"
						>
							<svg
								class="w-4 h-4"
								fill="none"
								stroke="currentColor"
								viewBox="0 0 24 24"
							>
								<path
									stroke-linecap="round"
									stroke-linejoin="round"
									stroke-width="2"
									d="M19 9l-7 7-7-7"></path>
							</svg>
						</button>
					</div>
				</div>

				<!-- Expanded State -->
				<div id="filter-expanded" class="transition-all duration-300">
					<!-- Row 1: Show Options & Search (responsive layout) -->
					<div class="rounded-t-lg bg-gray-50 dark:bg-gray-800 p-4">
						<!-- Mobile/Tablet: Updated layout with collapse button inline -->
						<div class="md:hidden space-y-4">
							<div
								class="flex items-center justify-between gap-4"
							>
								<div class="flex flex-wrap gap-4">
									<label
										class="flex items-center gap-2 cursor-pointer"
									>
										<input
											type="checkbox"
											id="filter-topics"
											value="topics"
											checked
											class="rounded border-gray-300 dark:border-gray-600 text-[var(--primary-color)] focus:ring-[var(--primary-color)]"
										/>
										<span class="text-sm">Topic</span>
									</label>
									<label
										class="flex items-center gap-2 cursor-pointer"
									>
										<input
											type="checkbox"
											id="filter-qualities"
											value="qualities"
											checked
											class="rounded border-gray-300 dark:border-gray-600 text-[var(--primary-color)] focus:ring-[var(--primary-color)]"
										/>
										<span class="text-sm">Quality</span>
									</label>
									<label
										class="flex items-center gap-2 cursor-pointer"
									>
										<input
											type="checkbox"
											id="filter-similes"
											value="similes"
											class="rounded border-gray-300 dark:border-gray-600 text-[var(--primary-color)] focus:ring-[var(--primary-color)]"
										/>
										<span class="text-sm">Simile</span>
									</label>
								</div>
								<!-- Collapse button moved to same row -->
								<button
									id="collapse-filters-btn"
									class="p-2 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-700 transition-colors flex-shrink-0"
									aria-label="Collapse filters"
								>
									<svg
										class="w-4 h-4"
										fill="none"
										stroke="currentColor"
										viewBox="0 0 24 24"
									>
										<path
											stroke-linecap="round"
											stroke-linejoin="round"
											stroke-width="2"
											d="M5 15l7-7 7 7"></path>
									</svg>
								</button>
							</div>
							<input
								type="text"
								id="search-input"
								placeholder="Filter by text..."
								class="w-full px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 focus:ring-2 focus:ring-[var(--primary-color)] focus:border-transparent text-[70%]"
							/>
						</div>

						<!-- Desktop: Single row layout -->
						<div class="hidden md:flex items-center gap-6">
							<div class="flex items-center gap-4 flex-shrink-0">
								<div class="flex items-center">
									<div
										class="w-5 h-5 text-gray-600 dark:text-gray-400"
									>
										<Fragment set:html={Funnel} />
									</div>
									<span
										class="text-sm font-medium text-gray-700 dark:text-gray-300"
									>
										Show:
									</span>
								</div>
								<div class="flex gap-4">
									<label
										class="flex items-center gap-2 cursor-pointer"
									>
										<input
											type="checkbox"
											id="filter-topics-desktop"
											value="topics"
											checked
											class="rounded border-gray-300 dark:border-gray-600 text-[var(--primary-color)] focus:ring-[var(--primary-color)]"
										/>
										<span class="text-sm">Topic</span>
									</label>
									<label
										class="flex items-center gap-2 cursor-pointer"
									>
										<input
											type="checkbox"
											id="filter-qualities-desktop"
											value="qualities"
											checked
											class="rounded border-gray-300 dark:border-gray-600 text-[var(--primary-color)] focus:ring-[var(--primary-color)]"
										/>
										<span class="text-sm">Quality</span>
									</label>
									<label
										class="flex items-center gap-2 cursor-pointer"
									>
										<input
											type="checkbox"
											id="filter-similes-desktop"
											value="similes"
											class="rounded border-gray-300 dark:border-gray-600 text-[var(--primary-color)] focus:ring-[var(--primary-color)]"
										/>
										<span class="text-sm">Simile</span>
									</label>
								</div>
							</div>

							<div class="flex-1 max-w-md">
								<input
									type="text"
									id="search-input-desktop"
									placeholder="Filter with text..."
									class="w-full px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 focus:ring-2 focus:ring-[var(--primary-color)] focus:border-transparent text-[70%]"
								/>
							</div>
						</div>
					</div>

					<!-- Row 2: A-Z Navigation (compact single row) -->
					<div
						class="bg-gray-50 dark:bg-gray-800 rounded-t-none rounded-b-lg p-3"
					>
						<div
							class="flex flex-wrap gap-1 justify-center lg:gap-2"
						>
							{
								alphabet.map((letter) => (
									<button
										data-letter={letter}
										class="alphabet-link text-sm lg:text-base px-1 py-1 rounded transition-all duration-200 text-gray-500 dark:text-gray-400 border border-transparent focus:outline-none"
									>
										{letter}
									</button>
								))
							}
						</div>
					</div>
				</div>
			</div>

			<!-- Loading State -->
			<div id="loading" class="text-center py-8">
				<div
					class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-gray-900 dark:border-gray-100"
				>
				</div>
				<p class="mt-2 text-gray-600 dark:text-gray-400">
					Loading teachings...
				</p>
			</div>

			<!-- Results Container -->
			<div id="results-container" class="hidden">
				<!-- Results -->
				<div id="results" class="space-y-6">
					<!-- Will be populated by JavaScript -->
				</div>

				<!-- No Results Message -->
				<div id="no-results" class="hidden text-center py-8">
					<p class="text-gray-600 dark:text-gray-400">
						No topics, qualities or similes found matching your
						criteria. <a href="/search" id="full-text-search-link">
							Try discourse search
						</a>
					</p>
				</div>
			</div>
		</div>
	</main>

	<script>
		import { DiscoverRenderer } from "../../utils/discover-renderer";
		import type { UnifiedContentItem } from "../../types/discover";

		let allData: UnifiedContentItem[] = [];
		let filteredData: UnifiedContentItem[] = [];
		let currentFilters = new Set(["topics", "qualities"]);
		let searchTerm = "";
		let expandedItems = new Set<string>();
		let searchTimeout: NodeJS.Timeout | null = null;

		// Sticky filter controls
		let isFilterCollapsed = false;
		let scrollTimeout: NodeJS.Timeout | null = null;
		let lastScrollY = 0;
		let hasAutoCollapsed = false; // Track if we've already auto-collapsed once

		const loadingEl = document.getElementById("loading");
		const resultsContainer = document.getElementById("results-container");
		const resultsEl = document.getElementById("results");
		const noResultsEl = document.getElementById("no-results");
		const searchInput = document.getElementById(
			"search-input"
		) as HTMLInputElement;
		const searchInputDesktop = document.getElementById(
			"search-input-desktop"
		) as HTMLInputElement;

		// Initialize renderer
		const renderer = new DiscoverRenderer(expandedItems, toggleExpanded);

		// Initialize
		document.addEventListener("DOMContentLoaded", async () => {
			await loadData();
			setupEventListeners();
			setupScrollSpy();
			setupStickyFilters();
			updateDisplay();
		});

		async function loadData() {
			try {
				const by = Array.from(currentFilters).join(",");
				const filter = searchTerm || "";
				const response = await fetch(
					`/api/discover?by=${by}&filter=${encodeURIComponent(filter)}`
				);
				const result = await response.json();

				if (result.success) {
					allData = result.data;
					filteredData = result.data; // API does the filtering now
					updateDisplay();
				} else {
					console.error("Failed to load data:", result.error);
				}
			} catch (error) {
				console.error("Error loading data:", error);
			}
		}

		function setupEventListeners() {
			// Filter checkboxes
			const checkboxes = document.querySelectorAll(
				'input[type="checkbox"]'
			);
			checkboxes.forEach((checkbox) => {
				checkbox.addEventListener("change", handleFilterChange);
			});

			// Search inputs - sync mobile and desktop
			if (searchInput) {
				searchInput.addEventListener("input", handleSearchInput);
			}
			if (searchInputDesktop) {
				searchInputDesktop.addEventListener("input", handleSearchInput);
			}

			// Alphabet links
			document.querySelectorAll(".alphabet-link").forEach((link) => {
				link.addEventListener("click", handleAlphabetClick);
			});
		}

		function setupScrollSpy() {
			const observerOptions: IntersectionObserverInit = {
				root: null,
				rootMargin: "-200px 0px -70% 0px", // Adjusted for sticky header + filters
				threshold: [0, 0.1, 0.5],
			};

			const observer = new IntersectionObserver(
				(entries: IntersectionObserverEntry[]) => {
					let maxRatio = 0;
					let activeElement: Element | null = null;

					entries.forEach((entry) => {
						if (
							entry.isIntersecting &&
							entry.intersectionRatio > maxRatio
						) {
							maxRatio = entry.intersectionRatio;
							activeElement = entry.target;
						}
					});

					if (activeElement) {
						const htmlElement = activeElement as HTMLElement;
						if (htmlElement.id) {
							const letter = htmlElement.id.replace(
								"letter-",
								""
							);
							updateActiveAlphabetLink(letter);
						}
					}
				},
				observerOptions
			);

			// Will observe letter sections after they're rendered
			window.setupLetterObserver = observer;
		}

		function updateActiveAlphabetLink(activeLetter: string) {
			document.querySelectorAll(".alphabet-link").forEach((link) => {
				const letter = link.getAttribute("data-letter");
				if (letter === activeLetter) {
					link.classList.add("alphabet-active");
				} else {
					link.classList.remove("alphabet-active");
					// Remove focus from inactive links to prevent lingering focus styling
					(link as HTMLButtonElement).blur();
				}
			});
		}

		function handleAlphabetClick(event: Event) {
			event.preventDefault();

			// Find the button element (could be event.target or its parent)
			let button = event.target as HTMLElement;

			// If we clicked on the span inside the button, get the button parent
			if (!button.hasAttribute("data-letter")) {
				button = button.closest(".alphabet-link") as HTMLButtonElement;
			}

			if (!button) {
				return;
			}

			// Don't scroll if disabled
			if ((button as HTMLButtonElement).disabled) {
				return;
			}

			const letter = button.getAttribute("data-letter");

			if (letter) {
				// Set active state immediately on click
				updateActiveAlphabetLink(letter);

				const targetElement = document.getElementById(
					`letter-${letter}`
				);

				if (targetElement) {
					// Account for sticky header + sticky filter controls
					const headerOffset = 200;
					const elementPosition = targetElement.offsetTop;
					const offsetPosition = elementPosition - headerOffset;

					window.scrollTo({
						top: Math.max(0, offsetPosition),
						behavior: "smooth",
					});
				}
			}
		}

		function handleFilterChange(event: Event) {
			const checkbox = event.target as HTMLInputElement;
			const value = checkbox.value;

			if (checkbox.checked) {
				currentFilters.add(value);
			} else {
				// Prevent unchecking if it's the only active filter
				if (currentFilters.size > 1) {
					currentFilters.delete(value);
				} else {
					checkbox.checked = true; // Revert the change
					return;
				}
			}

			// Sync checkboxes between mobile and desktop
			const mobileCheckbox = document.getElementById(
				`filter-${value}`
			) as HTMLInputElement;
			const desktopCheckbox = document.getElementById(
				`filter-${value}-desktop`
			) as HTMLInputElement;

			if (mobileCheckbox && mobileCheckbox !== checkbox) {
				mobileCheckbox.checked = checkbox.checked;
			}
			if (desktopCheckbox && desktopCheckbox !== checkbox) {
				desktopCheckbox.checked = checkbox.checked;
			}

			// Update active filters count
			if (window.updateActiveFiltersCount) {
				window.updateActiveFiltersCount();
			}

			loadData();
		}

		function handleSearchInput(event: Event) {
			const input = event.target as HTMLInputElement;
			searchTerm = input.value.trim();

			// Sync both search inputs
			if (searchInput && input !== searchInput) {
				searchInput.value = searchTerm;
			}
			if (searchInputDesktop && input !== searchInputDesktop) {
				searchInputDesktop.value = searchTerm;
			}

			// Debounce search to avoid too many API calls
			if (searchTimeout) {
				clearTimeout(searchTimeout);
			}
			updateFullTextSearchLink(searchTerm);
			searchTimeout = setTimeout(() => {
				loadData();
			}, 50);
		}

		function updateFullTextSearchLink(searchInput: string) {
			const fullTextSearchLink = document.querySelector(
				"#full-text-search-link"
			) as HTMLAnchorElement;

			if (fullTextSearchLink) {
				const filterValue = searchInput.trim();
				if (filterValue) {
					fullTextSearchLink.href = `/search?q=${encodeURIComponent(filterValue)}`;
				} else {
					fullTextSearchLink.href = "/search";
				}
			}
		}

		function toggleExpanded(itemId: string) {
			if (expandedItems.has(itemId)) {
				expandedItems.delete(itemId);
			} else {
				expandedItems.add(itemId);
			}
			updateDisplay();
		}

		// Make function globally available
		window.toggleExpanded = toggleExpanded;

		function updateDisplay() {
			if (loadingEl) loadingEl.classList.add("hidden");
			if (resultsContainer) resultsContainer.classList.remove("hidden");

			if (filteredData.length === 0) {
				if (resultsEl) resultsEl.innerHTML = "";
				if (noResultsEl) noResultsEl.classList.remove("hidden");
				updateAlphabetAvailability();
				return;
			}

			if (noResultsEl) noResultsEl.classList.add("hidden");
			updateAlphabetAvailability();
			renderer.renderResults(filteredData, resultsEl);

			// Set up intersection observer for scroll spy
			if (window.setupLetterObserver) {
				document
					.querySelectorAll('[id^="letter-"]')
					.forEach((section) => {
						window.setupLetterObserver.observe(section);
					});
			}
		}

		function updateAlphabetAvailability() {
			const availableLetters = new Set<string>();
			filteredData.forEach((item) => {
				availableLetters.add(item.title.charAt(0).toUpperCase());
			});

			document.querySelectorAll(".alphabet-link").forEach((link) => {
				const letter = link.getAttribute("data-letter");
				if (availableLetters.has(letter!)) {
					link.classList.remove("opacity-50", "cursor-not-allowed");
					(link as HTMLButtonElement).disabled = false;
				} else {
					link.classList.add("opacity-50", "cursor-not-allowed");
					link.classList.remove("alphabet-active");
					(link as HTMLButtonElement).disabled = true;
				}
			});
		}

		// Global function for window
		declare global {
			interface Window {
				toggleExpanded: (itemId: string) => void;
				setupLetterObserver: IntersectionObserver;
				updateActiveFiltersCount: () => void;
			}
		}

		function setupStickyFilters() {
			const filterControls = document.getElementById("filter-controls");
			const filterCollapsed = document.getElementById("filter-collapsed");
			const filterExpanded = document.getElementById("filter-expanded");
			const expandBtn = document.getElementById("expand-filters-btn");
			const collapseBtn = document.getElementById("collapse-filters-btn");

			if (!filterControls || !filterCollapsed || !filterExpanded) return;

			// Handle scroll behavior for mobile
			function handleScroll() {
				if (scrollTimeout) {
					clearTimeout(scrollTimeout);
				}

				scrollTimeout = setTimeout(() => {
					const currentScrollY = window.scrollY;
					const isMobile = window.innerWidth < 768; // md breakpoint

					if (isMobile) {
						// Auto-collapse on mobile when scrolling down - but only once
						if (
							currentScrollY > 1000 &&
							currentScrollY > lastScrollY &&
							!isFilterCollapsed &&
							!hasAutoCollapsed
						) {
							collapseFilters();
							hasAutoCollapsed = true; // Mark that we've auto-collapsed
						}
					}

					lastScrollY = currentScrollY;
				}, 100);
			}

			// Collapse filters (mobile only)
			function collapseFilters() {
				if (window.innerWidth >= 768) return; // Don't collapse on desktop

				isFilterCollapsed = true;
				if (filterCollapsed) filterCollapsed.classList.remove("hidden");
				if (filterExpanded) filterExpanded.classList.add("hidden");
				updateActiveFiltersCount();
			}

			// Expand filters
			function expandFilters() {
				isFilterCollapsed = false;
				if (filterCollapsed) filterCollapsed.classList.add("hidden");
				if (filterExpanded) filterExpanded.classList.remove("hidden");
			}

			// Update active filters count in collapsed state
			function updateActiveFiltersCount() {
				const countEl = document.getElementById("active-filters-count");
				if (countEl) {
					countEl.textContent = currentFilters.size.toString();
				}
			}

			// Event listeners
			if (expandBtn) {
				expandBtn.addEventListener("click", expandFilters);
			}

			if (collapseBtn) {
				collapseBtn.addEventListener("click", collapseFilters);
			}

			// Scroll listener
			window.addEventListener("scroll", handleScroll, { passive: true });

			// Handle window resize
			window.addEventListener("resize", () => {
				if (window.innerWidth >= 768 && isFilterCollapsed) {
					// Auto-expand on desktop
					expandFilters();
				}
			});

			// Make functions available globally for filter updates
			window.updateActiveFiltersCount = updateActiveFiltersCount;
		}
	</script>
</Layout>
