---
import Analytics from "@vercel/analytics/astro";
import SpeedInsights from "@vercel/speed-insights/astro";
// Add content styling with CSS classes
import "../styles/global.css";
import Navbar from "../components/Navbar.astro";
import Breadcrumbs from "../components/Breadcrumbs.astro";
import LastUpdated from "../components/LastUpdated.astro";
import Footer from "../components/Footer.astro";
import Collapse from "../components/Collapse.astro";
import BottomDrawer from "../components/BottomDrawer.astro";
import PrintFormatter from "../components/PrintFormatter.astro";
import TranslationMatches from "../components/TranslationMatches.astro";
import "../styles/content.css";
import Title from "../components/Title.astro";
import Description from "../components/Description.astro";
import FooterNavigation from "../components/FooterNavigation.astro";
import HighlightLayout from "../components/HighlightLayout.astro";
import ReadLaterButton from "../components/ReadLaterButton.astro";
import SaveButton from "../components/SaveButton.astro";
import ReadButton from "../components/ReadButton.astro";
import PaliButton from "../components/PaliButton.astro";
import PaliLayoutToggle from "../components/PaliLayoutToggle.astro";
import ParagraphToggle from "../components/ParagraphToggle.astro";
import ScrollToTop from "../components/ScrollToTop.astro";
import QualityTags from "../components/QualityTags.astro";
import Commentary from "../components/Commentary.astro";
import DiscourseImage from "../components/DiscourseImage.astro";
import ImageToggle from "../components/ImageToggle.astro";
import type { ContentImageData } from "../utils/contentImage";
import { debug } from "../utils/contentParser";

const paramTheme = Astro.url.searchParams.get("theme");
// Server-side theme is always dark initially
const serverTheme = paramTheme === "light" ? "light" : "dark";

const {
	id,
	fp,
	title,
	description,
	qualities,
	prev,
	next,
	lastUpdated,
	showReadLater = false,
	showSave = false,
	showRead = false,
	titleIcon = null,
	showAuth = false,
	showSearch = true,
	showPali = false,
	showFilter = false,
	hideNavbar = false,
	seoTitle = null, // Add new prop for SEO title
	paragraphRequest = null,
	commentary,
	contentImage = null, // Optional discourse header image
} = Astro.props as {
	id?: string;
	fp?: string;
	title?: string;
	description?: string;
	qualities?: string[];
	prev?: any;
	next?: any;
	lastUpdated?: string;
	showReadLater?: boolean;
	showSave?: boolean;
	showRead?: boolean;
	titleIcon?: string | null;
	showAuth?: boolean;
	showSearch?: boolean;
	showPali?: boolean;
	showFilter?: boolean;
	hideNavbar?: boolean;
	seoTitle?: string | null;
	paragraphRequest?: any;
	commentary?: string | string[];
	contentImage?: ContentImageData | null;
};

// Debug logging in development only
debug("title is: ", title, " fp: ", fp);
debug("qualities are: ", qualities);
debug("commentary is: ", commentary);
let SEOTitle = seoTitle;
if (!SEOTitle) {
	if (title != "Words of the Buddha" && title) {
		SEOTitle = title + " - Words of the Buddha";
	}
	if (id && fp?.includes("anthologies")) {
		SEOTitle = "Anthology - " + title;
	} else if (id) {
		SEOTitle =
			id.replace(/([A-Za-z]+)(\d)/, "$1 $2").toUpperCase() + " " + title;
	}
}
---

<html lang="en" class={serverTheme} dir="ltr">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />

		<!-- Preload critical fonts -->
		<link
			rel="preload"
			href="/assets/fonts/Spectral-Regular.woff2"
			as="font"
			type="font/woff2"
			crossorigin
		/>
		<link
			rel="preload"
			href="/assets/fonts/Spectral-Italic.woff2"
			as="font"
			type="font/woff2"
			crossorigin
		/>
		<link
			rel="preload"
			href="/assets/fonts/GentiumPlus-Regular.ttf"
			as="font"
			type="font/ttf"
			crossorigin="anonymous"
		/>

		<title>{SEOTitle || "Words of the Buddha"}</title>
		<meta
			name="description"
			content={description || "Default Description"}
		/>

		<!-- Open Graph / Social Media -->
		<meta property="og:title" content={SEOTitle || "Words of the Buddha"} />
		<meta
			property="og:description"
			content={description || "Default Description"}
		/>
		<meta property="og:type" content="article" />
		{
			contentImage && (
				<meta
					property="og:image"
					content={new URL(contentImage.image.src, Astro.url).href}
				/>
			)
		}

		<!-- Twitter Card -->
		<meta
			name="twitter:card"
			content={contentImage ? "summary_large_image" : "summary"}
		/>
		<meta
			name="twitter:title"
			content={SEOTitle || "Words of the Buddha"}
		/>
		<meta
			name="twitter:description"
			content={description || "Default Description"}
		/>
		{
			contentImage && (
				<meta
					name="twitter:image"
					content={new URL(contentImage.image.src, Astro.url).href}
				/>
			)
		}

		<meta
			name="viewport"
			content="width=device-width, initial-scale=1.0, viewport-fit=cover"
		/>
		<link rel="icon" type="image/x-icon" href="/favicon.ico" />
		<link rel="manifest" href="/manifest.webmanifest" />
		<meta name="theme-color" content="#111827" />
		<script is:inline>
			function getInitialTheme() {
				const storedTheme = localStorage.getItem("theme");
				const urlParams = new URLSearchParams(window.location.search);
				const pliParam = urlParams.get("pli");
				let paliMode = localStorage.getItem("paliMode") === "true";
				if (pliParam !== null) {
					paliMode = pliParam === "true";
					localStorage.setItem("paliMode", paliMode.toString());
				}
				document.documentElement.classList.toggle("pali-on", paliMode);
				const paliLookup = urlParams.get("enablePaliLookup");
				if (paliLookup) {
					localStorage.setItem("paliLookup", paliLookup === "true");
				} else if (!localStorage.getItem("paliLookup")) {
					localStorage.setItem("paliLookup", true);
				}

				const paramTheme = urlParams.get("theme");

				if (paramTheme === "light" || paramTheme === "dark") {
					return paramTheme;
				}

				if (storedTheme === "light" || storedTheme === "dark") {
					return storedTheme;
				}

				return window.matchMedia("(prefers-color-scheme: dark)").matches
					? "dark"
					: "light";
			}

			document.documentElement.classList.remove("light", "dark");
			const theme = getInitialTheme();
			document.documentElement.classList.add(theme);
			localStorage.setItem("theme", theme);
		</script>
		<!-- Optional per-page head slot (e.g., to inject pre-hydration scripts) -->
		<slot name="head" />
	</head>
	<body
		class="flex flex-col min-h-screen bg-[var(--background-color)] text-[var(--text-color)] [overflow-x:clip]"
	>
		<Analytics />
		<SpeedInsights />
		<BottomDrawer />
		<TranslationMatches />
		<PrintFormatter />
		<main class="flex-1 p-4">
			<div class="max-w-4xl mx-auto prose prose-lg dark:prose-invert">
				<HighlightLayout
					currentPath={fp}
					title={title}
					description={description}
				>
					{
						!hideNavbar && (
							<Navbar
								showAuth={showAuth}
								showSearch={showSearch}
							/>
						)
					}
					<Breadcrumbs path={fp || Astro.url.pathname} />
					{(<Description description={description} />)}
					{
						(showPali ||
							showReadLater ||
							showSave ||
							contentImage) && (
							<>
								<div class="flex items-center justify-between gap-1">
									<div class="flex items-center gap-1">
										{showPali && (
											<>
												<PaliButton />
												<PaliLayoutToggle />
											</>
										)}
										{contentImage && <ImageToggle />}
										<ParagraphToggle
											paragraphRequest={paragraphRequest}
										/>
									</div>
									<div class="flex items-center gap-1">
										{showReadLater && <ReadLaterButton />}
										{showSave && <SaveButton />}
									</div>
								</div>
							</>
						)
					}
					<div class="flex items-start justify-between">
						<Title
							id={id}
							title={title || ""}
							showFilter={showFilter}
						>
							{
								titleIcon && (
									<span
										class="inline-block w-4 h-4 mr-2 -mt-1 text-primary-color dark:text-primary-color"
										set:html={titleIcon}
									/>
								)
							}
						</Title>
					</div>
					{
						contentImage && (
							<DiscourseImage imageData={contentImage} />
						)
					}
					<Collapse defaultState="collapse" />
					<slot />
					<Commentary commentary={commentary} />
					{
						showRead && (
							<div class="flex justify-end mt-6 mb-4">
								<ReadButton />
							</div>
						)
					}
					{
						qualities && qualities.length > 0 && (
							<QualityTags tags={qualities} />
						)
					}
					{
						lastUpdated && (
							<LastUpdated lastUpdated={lastUpdated} path={fp} />
						)
					}
					<FooterNavigation prev={prev} next={next} />
					<Footer />
				</HighlightLayout>
			</div>
		</main>
		<ScrollToTop />
	</body>
	<script>
		// Register the Service Worker for offline support (dev and prod)
		if ("serviceWorker" in navigator) {
			window.addEventListener("load", () => {
				navigator.serviceWorker.register("/sw.js?v=5").catch(() => {
					/* ignore */
				});

				// After the SW takes control, cache already-loaded resources for offline use
				// This handles the case where resources loaded before the SW was controlling
				navigator.serviceWorker.ready
					.then(async () => {
						// Cache already-loaded JS/CSS resources that the SW missed on first load
						if (navigator.onLine && typeof caches !== "undefined") {
							try {
								const resources = performance.getEntriesByType(
									"resource",
								) as PerformanceResourceTiming[];
								const assetsToCache = resources
									.filter((r) => {
										const url = new URL(
											r.name,
											location.origin,
										);
										if (url.origin !== location.origin)
											return false;
										const path = url.pathname;
										return (
											path.endsWith(".js") ||
											path.endsWith(".mjs") ||
											path.endsWith(".css") ||
											path.startsWith("/_astro/")
										);
									})
									.map((r) => r.name);

								if (assetsToCache.length > 0) {
									const cache =
										await caches.open("assets-v1");
									await Promise.all(
										assetsToCache.map(async (url) => {
											try {
												const existing =
													await cache.match(url);
												if (existing) return;
												const res = await fetch(url, {
													cache: "force-cache",
												});
												if (res && res.ok) {
													await cache.put(url, res);
												}
											} catch {}
										}),
									);
								}
							} catch {}
						}

						// Prewarm the PÄli lookup chunk so it is cached for offline use.
						// This is intentionally low-priority and guarded by the user's preference.
						const pref = localStorage.getItem("paliLookup");
						const enabled = pref == null ? true : pref === "true";
						if (!enabled || !navigator.onLine) return;
						// Yield to the event loop/idle time before importing
						const prewarm = () =>
							import("../utils/paliLookup")
								.then((m) => m.warmupPaliDictionary?.())
								.catch(() => {});
						if ("requestIdleCallback" in window) {
							(requestIdleCallback as any)(prewarm, {
								timeout: 3000,
							});
						} else {
							setTimeout(prewarm, 0);
						}
					})
					.catch(() => {
						/* ignore */
					});
			});
		}

		import {
			handleNavigation,
			synchronizePreferences,
		} from "../utils/theme";
		import type { UserPreferences, Theme, FontSize } from "../utils/theme";

		// Load preferences once when the page loads
		document.addEventListener("DOMContentLoaded", async () => {
			const urlParams = new URLSearchParams(window.location.search);
			// Client-side safety net: if width < 768 and layout=split is present, drop it and clean the URL
			if (
				window.innerWidth < 768 &&
				urlParams.get("layout") === "split"
			) {
				urlParams.delete("layout");
				const newSearch = urlParams.toString();
				const newUrl = `${window.location.pathname}${newSearch ? `?${newSearch}` : ""}${window.location.hash}`;
				window.history.replaceState(null, "", newUrl);
			}
			const preferences: UserPreferences = {
				theme:
					(urlParams.get("theme") as Theme) ??
					localStorage.theme ??
					"dark",
				showPali: urlParams.get("pli") === "true",
				enablePaliLookup:
					urlParams.get("enablePaliLookup") ??
					localStorage.paliLookup ??
					false,
			};
			preferences.layout = preferences.showPali
				? window.innerWidth < 768
					? "interleaved"
					: ((urlParams.get("layout") as "split" | "interleaved") ??
						localStorage.layout ??
						"interleaved")
				: undefined;
			synchronizePreferences(preferences);
			// Defensive: strip stray ?layout/pli parameters that may have been appended to the hash fragment by copy/paste
			if (window.location.hash.includes("?")) {
				const cleanHash = window.location.hash
					.split("?")[0]
					.split("&")[0];
				const baseUrl = `${window.location.pathname}${window.location.search}${cleanHash}`;
				window.history.replaceState(null, "", baseUrl);
			}
			// Apply font size from localStorage
			const storedFontSize = localStorage.getItem("fontSize") || "large";
			const proseElements = document.querySelectorAll("article.prose");
			if (proseElements && storedFontSize === "larger") {
				proseElements.forEach((prose) => {
					prose.classList.remove("prose-lg", "prose-xl");
					prose.classList.add("prose-xl");
				});
			}

			// Add click handler for all navigation
			document.addEventListener("click", handleNavigation);

			// Helper function to parse hash and return paragraph numbers and scroll target
			function parseHashRange(hash: string): {
				paragraphs: number[];
				scrollTo: number | null;
			} {
				if (!hash) return { paragraphs: [], scrollTo: null };

				// Remove leading # and any accidental query-string fragments after the hash
				let hashValue = hash.startsWith("#") ? hash.slice(1) : hash;
				// If the hash mistakenly contains ?key=value or &key=value, keep only the paragraph part
				hashValue = hashValue.split(/[?&]/)[0];
				try {
					hashValue = decodeURIComponent(hashValue);
				} catch {}
				const paragraphNumbers: number[] = [];
				let scrollTo: number | null = null;

				// Split by comma to handle multiple values/ranges (e.g., "1,2,4-6")
				const parts = hashValue
					.split(",")
					.map((p) => p.trim())
					.filter(Boolean);

				for (const part of parts) {
					const trimmedPart = part.trim();
					if (!trimmedPart) continue;

					// Check for range format (e.g., "4-6")
					if (trimmedPart.includes("-")) {
						const [startStr, endStr] = trimmedPart.split("-");
						const startNum = Number(startStr);
						const endNum = Number(endStr);

						if (
							!isNaN(startNum) &&
							!isNaN(endNum) &&
							startNum <= endNum
						) {
							for (let i = startNum; i <= endNum; i++) {
								paragraphNumbers.push(i);
							}
							// Set scrollTo to the first paragraph if not already set
							if (scrollTo === null) {
								scrollTo = startNum;
							}
						}
					} else {
						// Single paragraph format (e.g., "1", "2")
						const paragraphNum = Number(trimmedPart);
						if (!isNaN(paragraphNum)) {
							paragraphNumbers.push(paragraphNum);
							// Set scrollTo to the first paragraph if not already set
							if (scrollTo === null) {
								scrollTo = paragraphNum;
							}
						}
					}
				}

				// Remove duplicates and sort
				const uniqueParagraphs = [...new Set(paragraphNumbers)].sort(
					(a, b) => a - b,
				);

				return {
					paragraphs: uniqueParagraphs,
					scrollTo: scrollTo,
				};
			}

			// Helper function to apply highlighting and navigation
			function applyHighlightingAndNavigation(
				paragraphNumbers: number[],
				scrollTargetId: number | null,
			): void {
				// Clear existing highlights
				document
					.querySelectorAll(".paragraph-highlight")
					.forEach((element) => {
						element.classList.remove("paragraph-highlight");
					});

				// Apply new highlights to all matching paragraph elements (interleaved and split)
				paragraphNumbers.forEach((paragraphNum) => {
					const selector = `[id="${paragraphNum}"]`;
					document.querySelectorAll(selector).forEach((el) => {
						el.classList.add("paragraph-highlight");
					});
				});

				// Navigate to target paragraph with smooth scroll
				if (scrollTargetId != null) {
					const idSel = `[id="${scrollTargetId}"]`;

					// Check if we're in split layout mode (Pali mode with split layout)
					const isSplitMode =
						document.documentElement.classList.contains(
							"pali-on",
						) && localStorage.getItem("layout") === "split";

					let targetElement: Element | null = null;

					if (isSplitMode) {
						// Prefer the English panel in split mode if available
						targetElement = document.querySelector(
							`#panel1 ${idSel}`,
						);
					}

					if (!targetElement) {
						// Fallback to interleaved article
						targetElement = document.querySelector(
							"article.prose " + idSel,
						);
					}
					if (!targetElement) {
						// Final fallback to any element with that id
						targetElement = document.querySelector(idSel);
					}

					if (targetElement) {
						// Wait for content to fully load and layout to complete
						const scrollToElement = () => {
							const rect = targetElement!.getBoundingClientRect();
							const absoluteTop = rect.top + window.pageYOffset;

							// If rect.top is 0 and we're at the top of the page, the element likely hasn't been laid out yet
							if (rect.top === 0 && window.pageYOffset === 0) {
								// Try again after a short delay
								setTimeout(scrollToElement, 50);
								return;
							}

							const scrollToPosition = Math.max(
								0,
								absoluteTop - 100,
							);
							window.scrollTo({
								top: scrollToPosition,
								behavior: "smooth",
							});
						};

						// Start with a small delay to let initial render complete
						setTimeout(scrollToElement, 50);
					}
				}
			}

			// Handle hash navigation for paragraph anchors
			function handleHashNavigation() {
				if (window.location.hash) {
					const hash = window.location.hash.substring(1);
					const { paragraphs, scrollTo } = parseHashRange(hash);
					applyHighlightingAndNavigation(paragraphs, scrollTo);
				}
			}

			// Handle initial hash navigation
			handleHashNavigation();

			// Listen for hash changes
			window.addEventListener("hashchange", handleHashNavigation);
			// Re-apply highlighting when layout or Pali mode changes
			document.addEventListener("layoutChanged", handleHashNavigation);
			document.addEventListener("paliModeChanged", handleHashNavigation);

			// Remove empty spans after preferences are applied
			document.querySelectorAll("span").forEach((span) => {
				const hasVisibleContent = /\S/.test(span.textContent ?? "");
				const hasMeaningfulAttributes = span.attributes.length > 0;

				if (!hasVisibleContent && !hasMeaningfulAttributes) {
					span.remove();
				}
			});
		});
	</script>
</html>
