<!-- this is a client-only script component -->
<script>
	// Helper function to parse Markdown-style links
	function parseMarkdownLinks(text: string) {
		return text.replace(
			/\[([^\]]+)\]\(([^)]+)\)/g,
			'<a href="$2" class="tooltip-link">$1</a>'
		);
	}

	// Helper to properly escape HTML for attribute values
	function escapeHtml(text: string) {
		return text
			.replace(/&/g, "&amp;")
			.replace(/</g, "&lt;")
			.replace(/>/g, "&gt;")
			.replace(/"/g, "&quot;")
			.replace(/'/g, "&#039;");
	}

	// Bottom popover manager
	class BottomPopover {
		private popover: HTMLElement | null = null;
		private isVisible: boolean = false;

		constructor() {
			this.createPopover();
		}

		private createPopover() {
			this.popover = document.createElement("div");
			this.popover.className = "bottom-popover";
			this.popover.innerHTML = `
				<div class="popover-content">
					<button class="close-btn" aria-label="Close">
						<svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
							<path d="M3.72 3.72a.75.75 0 0 1 1.06 0L8 6.94l3.22-3.22a.75.75 0 1 1 1.06 1.06L9.06 8l3.22 3.22a.75.75 0 1 1-1.06 1.06L8 9.06l-3.22 3.22a.75.75 0 0 1-1.06-1.06L6.94 8 3.72 4.78a.75.75 0 0 1 0-1.06z"/>
						</svg>
					</button>
					<div class="popover-body"></div>
				</div>
			`;

			// Add close button event
			const closeBtn = this.popover.querySelector(".close-btn");
			closeBtn?.addEventListener("click", () => this.hide());

			document.body.appendChild(this.popover);
		}

		show(
			content: string,
			contentType: "markdown" | "dictionary",
			primaryText?: string
		) {
			if (!this.popover) return;

			const contentEl = this.popover.querySelector(".popover-body");
			if (!contentEl) return;

			if (contentType === "markdown") {
				// For |text::tooltip| content - show primary word/phrase
				// Extract bracketed text (Pali term) from content
				const bracketMatch = content.match(/\[([^\]]+)\]$/);
				const paliTerm = bracketMatch ? bracketMatch[1] : null;
				const cleanContent = paliTerm
					? content.replace(/\s*\[([^\]]+)\]$/, "")
					: content;

				contentEl.innerHTML = `
					<div class="tooltip-content markdown-content">
						${
							primaryText
								? `
							<div class="title">
								<span class="title-text">${primaryText}</span>
								${paliTerm ? `<span class="pali-term">[${paliTerm}]</span>` : ""}
							</div>
						`
								: ""
						}
						<div class="definition">${cleanContent}</div>
					</div>
				`;
			} else {
				// For Pali dictionary content
				contentEl.innerHTML = content;
			}

			this.popover.classList.add("visible");
			this.isVisible = true;

			// Handle link clicks within popover
			this.setupLinkHandlers();
		}

		hide() {
			if (!this.popover) return;
			this.popover.classList.remove("visible");
			this.isVisible = false;
		}

		private setupLinkHandlers() {
			const links = this.popover?.querySelectorAll(".tooltip-link, a");
			links?.forEach((link) => {
				link.addEventListener("click", (e) => {
					if (link instanceof HTMLAnchorElement) {
						e.preventDefault();
						window.location.href = link.getAttribute("href") || "";
						this.hide();
					}
				});
			});
		}

		isOpen() {
			return this.isVisible;
		}
	}

	// Global popover instance
	let bottomPopover: BottomPopover;

	function replaceTooltips(element: HTMLElement) {
		for (let node of element.childNodes) {
			if (node.nodeType === Node.TEXT_NODE) {
				let text = node.textContent || "";
				// Replace |text::tooltip| pattern
				text = text.replace(
					/\|([^|:]+)::([^|]+)\|/g,
					(_, textPart, tooltip) => {
						// Parse any Markdown links in the tooltip content
						const parsedTooltip = parseMarkdownLinks(tooltip);
						// Store original content for popover
						return `<span class="tooltip-text" data-tooltip-content="${escapeHtml(parsedTooltip)}">${textPart}</span>`;
					}
				);
				const span = document.createElement("span");
				span.innerHTML = text;
				if (node.parentNode) {
					node.parentNode.replaceChild(span, node);
				}
			} else if (
				node.nodeType === Node.ELEMENT_NODE &&
				node instanceof HTMLElement
			) {
				replaceTooltips(node);
			}
		}
	}

	async function showDictionaryPopover(word: string) {
		if (!bottomPopover) return;

		// Show loading state
		bottomPopover.show(
			`
			<div class="loading-spinner">
				<svg class="animate-spin h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
					<circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
					<path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
				</svg>
				<span class="ml-2">Loading definition...</span>
			</div>
		`,
			"dictionary"
		);

		try {
			const response = await fetch(
				`/api/pali/lookup?word=${encodeURIComponent(word)}`
			);
			const data = await response.json();
			if (data.definitions && data.definitions.length > 0) {
				const content = createTooltipContent(word, data);
				bottomPopover.show(content, "dictionary");
			} else {
				bottomPopover.show("No definition found", "dictionary");
			}
		} catch (error) {
			console.error("Failed to fetch definition:", error);
			bottomPopover.show("Failed to load definition", "dictionary");
		}
	}

	function createTooltipContent(word: string, data: any) {
		const { definitions } = data;
		return `
			<div class="tooltip-content">
				<div class="title">
					<span>
						${definitions[0] ? definitions[0].lemma.replace(/ \d+$/, "") : word}
						<span style="margin-left: 8px">
							${definitions[0].pos ? `<span class="grammar">${definitions[0].pos}</span>` : ""}
						</span>
					</span>
					${
						definitions[0].construction
							? `
						<span>
							<span class="construction">${definitions[0].construction.replace(/\n/g, " ; ")}</span>
						</span>`
							: ""
					}
				</div>
				<div class="dpd-content">
					${definitions
						.map(
							(def: any, idx: number) => `
						<div class="summary${idx === definitions.length - 1 ? " last" : ""}">
							<div class="def-line">
								<span class="meaning">${idx + 1}. ${def.meaning}${def.meaning_lit ? ";" : ""}</span>
								${def.meaning_lit ? `<span class="meaning" style="font-style: italic;">lit. ${def.meaning_lit}</span>` : ""}
							</div>
						</div>
					`
						)
						.join("")}
				</div>
			</div>
		`;
	}

	document.addEventListener("DOMContentLoaded", () => {
		replaceTooltips(document.body);
		bottomPopover = new BottomPopover();

		// Handle |text::tooltip| clicks
		document.addEventListener("click", (e) => {
			const tooltipElement = (e.target as HTMLElement).closest(
				".tooltip-text"
			);
			if (tooltipElement) {
				e.preventDefault();
				const content =
					tooltipElement.getAttribute("data-tooltip-content") || "";
				const primaryText = tooltipElement.textContent || "";
				bottomPopover.show(content, "markdown", primaryText);
			}
		});

		// Handle Pali word lookup if enabled
		if (localStorage.getItem("paliLookup") === "true") {
			// Desktop: double-click handler
			if (!("ontouchstart" in window)) {
				document.addEventListener("dblclick", (e) => {
					const target = e.target as HTMLElement;
					if (!target.closest(".pali-paragraph")) return;

					const selection = window.getSelection();
					const text = selection?.toString().trim();
					if (!text || /\s/.test(text)) return;

					showDictionaryPopover(text);
				});
			}

			// Mobile: touch handler
			if ("ontouchstart" in window) {
				let startTouch: Touch | null = null;

				document.addEventListener("contextmenu", (e) => {
					const target = e.target as HTMLElement;
					if (target.closest(".pali-paragraph")) {
						e.preventDefault();
					}
				});

				document.addEventListener(
					"touchstart",
					(e) => {
						const target = e.target as HTMLElement;
						if (!target.closest(".pali-paragraph")) return;
						startTouch = e.touches[0];
					},
					{ passive: true }
				);

				document.addEventListener(
					"touchend",
					(e) => {
						if (!startTouch) return;

						const selection = window.getSelection();
						const text = selection?.toString().trim();

						if (text && !text.includes(" ")) {
							showDictionaryPopover(text);
						}
						startTouch = null;
					},
					{ passive: true }
				);
			}
		}
	});
</script>

<style is:global>
	.bottom-popover {
		position: fixed;
		bottom: 0;
		left: 0;
		right: 0;
		width: 100vw;
		height: 25vh;
		background-color: var(--background-color);
		border-top: 1px solid var(--popover-border);
		box-shadow:
			0 -4px 6px -1px rgba(0, 0, 0, 0.1),
			0 -2px 4px -1px rgba(0, 0, 0, 0.06);
		transform: translateY(100%);
		transition: transform 0.3s ease-in-out;
		z-index: 1000;
		display: flex;
		flex-direction: column;
	}

	html.dark .bottom-popover {
		box-shadow:
			0 -4px 6px -1px rgba(0, 0, 0, 0.3),
			0 -2px 4px -1px rgba(0, 0, 0, 0.2);
	}

	.bottom-popover.visible {
		transform: translateY(0);
	}

	.popover-content {
		position: relative;
		padding: 1.5rem 1.5rem 2rem;
		overflow-y: auto;
		flex: 1;
	}

	.close-btn {
		position: absolute;
		top: 1rem;
		right: 1rem;
		background: none;
		border: none;
		color: var(--text-color);
		cursor: pointer;
		padding: 0.25rem;
		border-radius: 0.25rem;
		transition: background-color 0.2s;
		z-index: 1;
	}

	.close-btn:hover {
		background-color: var(--background-row-hover);
	}

	.popover-body {
		padding-right: 3rem; /* Make room for close button */
	}

	/* Tooltip text styling - remove underline effect */
	.tooltip-text {
		cursor: pointer;
	}

	/* Preserve existing tooltip content styles */
	.tooltip-content .title {
		color: var(--primary-color);
		font-weight: 500;
		border-bottom: 1px solid var(--auth-input-border);
		margin-bottom: 0.5rem;
		padding-bottom: 0.5rem;
		font-size: 0.9rem;
		line-height: 1.6;
	}

	html.dark .tooltip-content .title {
		color: var(--primary-color);
	}

	.tooltip-content .title-text {
		color: inherit;
	}

	.tooltip-content .pali-term {
		color: var(--text-muted);
		font-weight: 400;
		margin-left: 0.25rem;
	}

	.tooltip-content .grammar {
		color: var(--secondary-color);
		font-style: italic;
		margin-right: 0.5rem;
	}

	.tooltip-content .meaning {
		display: inline;
		margin: 0;
	}

	.tooltip-content .construction {
		font-size: 0.8rem;
		color: var(--text-color);
		opacity: 0.7;
		margin-top: 0.25rem;
	}

	.tooltip-content .summary:not(.last) {
		border-bottom: 1px solid var(--auth-input-border);
		margin-bottom: 0.5rem;
		padding-bottom: 0.5rem;
	}

	.tooltip-link,
	.popover-content a {
		color: var(--link-color);
		text-decoration: underline;
		cursor: pointer;
	}

	.loading-spinner {
		display: flex;
		align-items: center;
		justify-content: center;
		padding: 2rem;
		color: var(--text-color);
	}

	@keyframes spin {
		to {
			transform: rotate(360deg);
		}
	}

	.animate-spin {
		animation: spin 1s linear infinite;
	}

	/* Markdown content styling */
	.markdown-content .definition {
		color: var(--text-color);
		line-height: 1.6;
	}
</style>
