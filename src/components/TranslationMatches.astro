---
/**
 * Translation Memory Matches Component
 * MVP Phase - Client-side matching and popover display
 * Only active in development mode
 */
---

{import.meta.env.DEV && (
<style is:global>
  .tm-lookup-btn {
    background: #ddd6fe;
    color: #5b21b6;
    border: none;
    border-radius: 0.25rem;
    padding: 0.125rem 0.375rem;
    font-size: 0.625rem;
    font-weight: 600;
    cursor: pointer;
    opacity: 0.7;
    transition: opacity 0.15s ease;
    user-select: none; /* Prevent TM button from being included in copy */
  }

  .tm-lookup-btn:hover {
    opacity: 1;
    background: #c4b5fd;
  }

  .dark .tm-lookup-btn {
    background: #4c1d95;
    color: #ddd6fe;
  }

  .dark .tm-lookup-btn:hover {
    background: #5b21b6;
  }

  .tm-popover-overlay {
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.5);
    z-index: 50;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 1rem;
  }

  .tm-popover {
    background: white;
    border-radius: 0.5rem;
    box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
    width: calc(100vw - 2rem);
    height: calc(100vh - 2rem);
    max-width: 1200px;
    max-height: calc(100vh - 2rem);
    overflow-y: auto;
    display: flex;
    flex-direction: column;
  }

  .dark .tm-popover {
    background: #1f2937;
    color: #f3f4f6;
  }

  .tm-popover-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.875rem 1rem;
    border-bottom: 1px solid #e5e7eb;
    gap: 0.5rem;
  }

  .dark .tm-popover-header {
    border-bottom-color: #374151;
  }

  .tm-popover-title {
    font-weight: 600;
    font-size: 0.9375rem;
    line-height: 1.4;
    color: #374151;
  }

  .dark .tm-popover-title {
    color: #e5e7eb;
  }

  .tm-popover-title .tm-discourse-count {
    font-weight: 400;
    color: #6b7280;
    font-size: 0.875rem;
  }

  .dark .tm-popover-title .tm-discourse-count {
    color: #9ca3af;
  }

  .tm-tabs {
    display: flex;
    gap: 0.25rem;
    padding: 0.5rem 1rem;
    background: #f3f4f6;
    border-bottom: 1px solid #e5e7eb;
    align-items: center;
    flex-wrap: wrap;
  }

  .dark .tm-tabs {
    background: #111827;
    border-bottom-color: #374151;
  }

  /* Row 1: Phrase pattern tabs - slightly different styling */
  .tm-phrase-tabs {
    background: #e0e7ff;
    border-bottom-color: #c7d2fe;
  }

  .dark .tm-phrase-tabs {
    background: #1e1b4b;
    border-bottom-color: #312e81;
  }

  .tm-phrase-tab {
    font-weight: 500;
  }

  /* Row 2: Discourse tabs - default styling */
  .tm-discourse-tabs {
    padding-top: 0.375rem;
    padding-bottom: 0.375rem;
  }

  .tm-more-count {
    font-size: 0.75rem;
    color: #6b7280;
    padding: 0.375rem 0.5rem;
    font-style: italic;
  }

  .dark .tm-more-count {
    color: #9ca3af;
  }

  .tm-tab {
    padding: 0.375rem 0.75rem;
    font-size: 0.8125rem;
    border: none;
    background: transparent;
    color: #6b7280;
    cursor: pointer;
    border-radius: 0.25rem;
    transition: all 0.15s ease;
    outline: none;
  }

  /* Focus ring for keyboard navigation */
  .tm-tab:focus-visible {
    box-shadow: 0 0 0 2px #6366f1, 0 0 0 4px rgba(99, 102, 241, 0.3);
  }

  .dark .tm-tab:focus-visible {
    box-shadow: 0 0 0 2px #818cf8, 0 0 0 4px rgba(129, 140, 248, 0.3);
  }

  /* Inactive tab hover - show preview of active state (lighter shade) */
  .tm-tab:not(.tm-tab-active):hover {
    background: #a5b4fc;
    color: white;
  }

  .dark .tm-tab:not(.tm-tab-active):hover {
    background: #4f46e5;
    color: white;
  }

  /* Active tab - no hover effect, cursor indicates no action */
  .tm-tab-active {
    background: #6366f1;
    color: white;
    cursor: default;
  }

  .dark .tm-tab-active {
    background: #6366f1;
    color: white;
  }

  /* Wrapper-based highlight - wraps contiguous matched range */
  .tm-highlight {
    background: #fef08a;
    padding: 0.125rem 0.25rem;
    border-radius: 0.25rem;
    display: inline;
  }

  .dark .tm-highlight {
    background: #854d0e;
    color: #fef3c7;
  }

  /* Matched words inside the highlight wrapper */
  .tm-highlight-word {
    font-weight: 600;
  }

  .dark .tm-highlight-word {
    /* inherits from wrapper */
  }

  /* Gap words - within matched range but not covered by n-grams */
  .tm-highlight-gap {
    font-weight: 500;
    border-bottom: 2px dashed #d97706;
    opacity: 0.8;
  }

  .dark .tm-highlight-gap {
    border-bottom: 2px dashed #fbbf24;
  }

  /* Pali words in TM popover - clickable for dictionary */
  .tm-popover .pali-word {
    cursor: pointer;
    transition: background-color 0.15s ease, color 0.15s ease;
    border-radius: 0.125rem;
  }

  .tm-popover .pali-word:hover {
    background: rgba(99, 102, 241, 0.2);
  }

  .dark .tm-popover .pali-word:hover {
    background: rgba(99, 102, 241, 0.35);
  }

  /* Active word being looked up in dictionary - distinct from highlight */
  .tm-popover .pali-word-highlighted {
    background: #6366f1 !important;
    color: white !important;
    border-radius: 0.125rem;
  }

  .dark .tm-popover .pali-word-highlighted {
    background: #818cf8 !important;
    color: #1e1b4b !important;
  }

  .tm-popover-close {
    background: none;
    border: none;
    font-size: 1.5rem;
    cursor: pointer;
    color: #6b7280;
    line-height: 1;
    padding: 0.25rem;
  }

  .tm-popover-close:hover {
    color: #374151;
  }

  .dark .tm-popover-close:hover {
    color: #d1d5db;
  }

  .tm-popover-content {
    padding: 1rem;
    flex: 1;
    overflow-y: auto;
  }

  .tm-section {
    margin-bottom: 1rem;
  }

  .tm-section:last-child {
    margin-bottom: 0;
  }

  .tm-section-label {
    font-size: 0.75rem;
    font-weight: 600;
    text-transform: uppercase;
    color: #6b7280;
    margin-bottom: 0.5rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .tm-discourse-link {
    font-size: 0.6875rem;
    font-weight: 500;
    text-transform: none;
    background: #e0e7ff;
    color: #3730a3;
    padding: 0.125rem 0.375rem;
    border-radius: 0.25rem;
    text-decoration: none;
    transition: background-color 0.15s ease;
  }

  .tm-discourse-link:hover {
    background: #c7d2fe;
    text-decoration: none;
  }

  .dark .tm-discourse-link {
    background: #312e81;
    color: #c7d2fe;
  }

  .dark .tm-discourse-link:hover {
    background: #3730a3;
  }

  .dark .tm-section-label {
    color: #9ca3af;
  }

  .tm-section-content {
    font-size: 0.9375rem;
    line-height: 1.6;
    white-space: pre-wrap;
  }

  .tm-pali {
    font-family: 'Gentium Plus', serif;
    font-style: italic;
    color: #4b5563;
  }

  .dark .tm-pali {
    color: #d1d5db;
  }

  .tm-source-pali {
    background: #fef3c7;
    padding: 0.75rem;
    border-radius: 0.375rem;
    border-left: 3px solid #f59e0b;
  }

  .dark .tm-source-pali {
    background: #451a03;
    border-left-color: #d97706;
  }

  .tm-english {
    color: #1f2937;
  }

  .dark .tm-english {
    color: #f3f4f6;
  }

  /* Matched phrase section - less prominent highlight */
  .tm-matched-phrase {
    background: #f3f4f6;
    padding: 0.75rem;
    border-radius: 0.375rem;
    border-left: 3px solid #9ca3af;
  }

  .dark .tm-matched-phrase {
    background: #1f2937;
    border-left-color: #6b7280;
  }

  /* Selection-based copy tooltip */
  .tm-selection-copy-tooltip {
    background: #1f2937;
    border-radius: 0.375rem;
    padding: 0.25rem;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
  }

  .tm-selection-copy-btn {
    display: flex;
    align-items: center;
    gap: 0.25rem;
    padding: 0.375rem 0.625rem;
    font-size: 0.75rem;
    background: transparent;
    color: white;
    border: none;
    border-radius: 0.25rem;
    cursor: pointer;
    white-space: nowrap;
    transition: background-color 0.15s ease;
  }

  .tm-selection-copy-btn:hover {
    background: rgba(255, 255, 255, 0.1);
  }

  .tm-selection-copy-btn.copied {
    background: #10b981;
  }

  /* Gloss tooltip styles */
  .tm-gloss {
    border-bottom: 1px dotted #6b7280;
    cursor: help;
  }

  .tm-gloss:hover {
    background: rgba(99, 102, 241, 0.1);
  }

  .dark .tm-gloss {
    border-bottom-color: #9ca3af;
  }
</style>

<script>
  // Translation Memory - Client-side matching and display
  // Only runs in dev mode

  // Import routes to check if a path is a valid discourse
  import { routes } from '../utils/routes';
  const routeSet = new Set(routes);

  interface TMEntry {
    id: number;
    paliNormalized: string;
    paliOriginal: string;
    englishOriginal: string;
    wordCount: number;
    source: {
      suttaId: string;
      paragraphNum: number;
      collection: string;
    };
  }

  // N-gram index type
  type NgramIndex = Record<string, number[]>;

  interface TranslationMemoryIndex {
    version: number;
    generatedAt: string;
    entries: TMEntry[];
    ngrams?: NgramIndex;
    ngramSize?: number;
  }

  // A single discourse that has a matching phrase
  interface TMDiscourse {
    suttaId: string;
    paragraphNum: number;
    collection: string;
    paliOriginal: string;
    englishOriginal: string;
    matchedWords?: Set<string>;    // Per-discourse matched words (optional for backward compat)
    contentWordCount?: number;     // Per-discourse content word count
    entryStartIndex?: number;      // Position where match starts in entry text
    entryEndIndex?: number;        // Position where match ends in entry text
    entryCoveredPositions?: Set<number>; // Which positions in entry text are actually covered (not gaps)
  }

  // A group of discourses that share the same phrase pattern
  interface TMPhraseGroup {
    phraseNormalized: string;
    similarity: number;
    score: number; // Internal score for debug output
    matchedWordCount: number;
    contentWordCount: number; // Non-stop words count
    matchedWords: Set<string>;
    matchedSegment: string; // The actual matched segment text for debugging
    startIndex?: number; // Source position range start
    endIndex?: number;   // Source position range end
    coveredPositions?: Set<number>; // Which positions in source text are covered (not gaps)
    discourses: TMDiscourse[]; // Stored discourses for diversity selection
    totalCount: number; // True count of all matches (may exceed stored)
    diverseDiscourses: TMDiscourse[]; // Top 3 diverse for display
  }

  interface TMMatchResult {
    phraseGroups: TMPhraseGroup[];
    sourcePali: string;
    totalDiscourses: number;
    sourceWordCount: number; // Total words in source paragraph for percentage calculation
    sourceRef?: { suttaId: string; paragraphNum: number }; // Source paragraph reference for display
  }

  const THRESHOLDS = {
    PARAGRAPH_SIMILARITY: 0.75,
    WORD_COUNT_TOLERANCE: 0.50,
    MAX_PHRASE_GROUPS: 10,
    MAX_DISCOURSES_TO_STORE: 20, // Store enough for diversity selection
  };

  // Pali stop words - common particles and forms that appear frequently
  // These don't count toward match length but still need to be present
  const PALI_STOP_WORDS = new Set([
    // Particles
    'ca', 'vā', 'kho', 'pana', 'hi', 'eva', 'pi', 'nu', 'nanu', 'su', 've', 'tu', 'atha',
    'ime', 'imā', 'imāni', 'imaṁ', // these/this forms
    // Common address terms and their grammatical variants
    'bhante',
    'āvuso',
    'bhikkhu', 'bhikkhū', 'bhikkhuṁ', 'bhikkhuno', 'bhikkhussa', 'bhikkhave', 'bhikkhavo',
    'āyasmā', 'āyasmant', 'āyasmantaṁ', 'āyasmato', 'āyasmante',
    // Demonstratives and pronouns
    'so', 'sā', 'taṁ', 'te', 'tassa', 'tesaṁ', 'ayaṁ', 'idaṁ', 'etaṁ', 'yo', 'yā', 'yaṁ', 'ye',
    // Common verb forms
    'hoti', 'bhavati', 'atthi', 'iti', 'ti',
    // Conjunctions
    'yathā', 'tathā', 'yadā', 'tadā',
    // Articles/determiners (Pali doesn't really have these but some common forms)
    'eko', 'ekā', 'ekaṁ',
  ]);

  let tmIndex: TranslationMemoryIndex | null = null;

  // Normalize Pali text for matching
  function normalizePali(text: string): string {
    return text
      .toLowerCase()
      // Strip all quotes - using Unicode escapes to be explicit
      .replace(/['"«»„\u2018\u2019\u201A\u201B\u201C\u201D\u201E\u201F\u2039\u203A]/g, '')
      // Replace punctuation with space (not remove) to preserve word boundaries
      .replace(/[।.,;:!?…—–\-\(\)\[\]\{\}]/g, ' ')
      .replace(/\s+/g, ' ')
      .trim();
  }

  // Check if a word is a stop word
  function isStopWord(word: string): boolean {
    return PALI_STOP_WORDS.has(word);
  }

  // Count content words (non-stop words) in an array
  function countContentWords(words: string[]): number {
    return words.filter(w => !isStopWord(w)).length;
  }

  // Find contiguous match between two word arrays
  // Tries both directions and returns the better match:
  // 1. Entry phrase found within source (short entry in long source)
  // 2. Source phrase found within entry (source in long corpus entry)
  function findContiguousMatch(entryWords: string[], queryWords: string[]): {
    startIndex: number;
    endIndex: number;
    matchedWords: string[];
    score: number;
    contentWordCount: number;
  } | null {
    if (entryWords.length === 0 || queryWords.length === 0) return null;

    const maxGap = 2; // Allow up to 2 words gap for flexibility

    // Try to find shorter array within longer array
    // This handles both directions naturally
    function slideMatch(shortWords: string[], longWords: string[]): {
      matchedWords: string[];
      score: number;
      contentWordCount: number;
    } | null {
      let bestMatch: { matchedWords: string[]; score: number; contentWordCount: number } | null = null;

      for (let longStart = 0; longStart < longWords.length; longStart++) {
        let sIdx = 0; // short index
        let lIdx = longStart; // long index
        let matched: string[] = [];
        let lastMatchLIdx = longStart - 1;

        while (sIdx < shortWords.length && lIdx < longWords.length) {
          if (shortWords[sIdx] === longWords[lIdx]) {
            // Check gap
            if (matched.length > 0 && (lIdx - lastMatchLIdx) > maxGap + 1) {
              break;
            }
            matched.push(shortWords[sIdx]);
            lastMatchLIdx = lIdx;
            sIdx++;
            lIdx++;
          } else {
            lIdx++;
            if (matched.length > 0 && (lIdx - lastMatchLIdx) > maxGap + 1) {
              break;
            }
          }
        }

        if (matched.length >= 3) {
          // Score based on how much of the SHORT array we matched
          const score = matched.length / shortWords.length;
          const contentWordCount = countContentWords(matched);
          const effectiveScore = contentWordCount >= 2 ? score : score * 0.5;

          if (!bestMatch || effectiveScore > bestMatch.score ||
              (effectiveScore === bestMatch.score && contentWordCount > bestMatch.contentWordCount)) {
            bestMatch = { matchedWords: matched, score, contentWordCount };
          }
        }
      }

      return bestMatch;
    }

    // Try both directions
    const entryInQuery = slideMatch(entryWords, queryWords); // Entry phrase in source
    const queryInEntry = slideMatch(queryWords, entryWords); // Source phrase in entry

    // Pick the better match
    let best: { matchedWords: string[]; score: number; contentWordCount: number } | null = null;

    if (entryInQuery && queryInEntry) {
      // Both matched - prefer the one with higher score, or more content words as tiebreaker
      if (entryInQuery.score > queryInEntry.score ||
          (entryInQuery.score === queryInEntry.score && entryInQuery.contentWordCount >= queryInEntry.contentWordCount)) {
        best = entryInQuery;
      } else {
        best = queryInEntry;
      }
    } else {
      best = entryInQuery || queryInEntry;
    }

    if (!best) return null;

    return {
      startIndex: 0, // Not used for highlighting source - we use matchedWords
      endIndex: 0,
      matchedWords: best.matchedWords,
      score: best.score,
      contentWordCount: best.contentWordCount,
    };
  }

  // Word pattern for extracting words - must match the pattern used in renderPaliWithWords
  const WORD_PATTERN = /[a-zA-ZāīūṃṅñṭḍṇḷṁĀĪŪṂṄÑṬḌṆḶṀ'"\u2018\u2019\u201A\u201B\u201C\u201D\u201E\u201F\u2039\u203A«»„‚]+/g;

  // Extract words from text using the same pattern as rendering
  // This ensures word positions match between index lookup and highlighting
  function extractWordsForHighlight(text: string): string[] {
    const normalizedText = text.replace(/\s+/g, ' ');
    const matches = [...normalizedText.matchAll(WORD_PATTERN)];
    return matches.map(m => normalizePali(m[0])).filter(w => w.length > 0);
  }

  // Extract n-grams from normalized text
  function extractNgrams(words: string[], n: number): string[] {
    if (words.length < n) return [];
    const ngrams: string[] = [];
    for (let i = 0; i <= words.length - n; i++) {
      ngrams.push(words.slice(i, i + n).join(' '));
    }
    return ngrams;
  }

  // Check if matched n-grams appear in consistent order between source and entry
  // Returns true if the n-grams are in the same relative order (allowing gaps)
  function checkNgramOrderConsistency(
    sourceWords: string[],
    entryWords: string[],
    matchedNgrams: Set<string>,
    ngramSize: number
  ): boolean {
    if (matchedNgrams.size <= 1) return true; // Single n-gram always consistent

    const sourceNgrams = extractNgrams(sourceWords, ngramSize);
    const entryNgrams = extractNgrams(entryWords, ngramSize);

    // Find positions of matched n-grams in each text
    const sourcePositions: Map<string, number> = new Map();
    const entryPositions: Map<string, number> = new Map();

    sourceNgrams.forEach((ngram, idx) => {
      if (matchedNgrams.has(ngram) && !sourcePositions.has(ngram)) {
        sourcePositions.set(ngram, idx);
      }
    });

    entryNgrams.forEach((ngram, idx) => {
      if (matchedNgrams.has(ngram) && !entryPositions.has(ngram)) {
        entryPositions.set(ngram, idx);
      }
    });

    // Get n-grams that exist in both, sorted by source position
    const commonNgrams = [...matchedNgrams].filter(
      ng => sourcePositions.has(ng) && entryPositions.has(ng)
    );

    if (commonNgrams.length <= 1) return true;

    // Sort by source position
    commonNgrams.sort((a, b) => sourcePositions.get(a)! - sourcePositions.get(b)!);

    // Check if entry positions are also in increasing order
    let lastEntryPos = -1;
    for (const ngram of commonNgrams) {
      const entryPos = entryPositions.get(ngram)!;
      if (entryPos < lastEntryPos) {
        return false; // Out of order
      }
      lastEntryPos = entryPos;
    }

    return true;
  }

  // Known Pali verb conjugation pairs - forms of the same verb that look very different
  // These are common "to be" and auxiliary verb forms that appear frequently
  const PALI_VERB_PAIRS: [string, string][] = [
    ['hoti', 'ahosi'],    // present vs past of "to be"
    ['hoti', 'ahosiṁ'],   // with first person ending
    ['hoti', 'bhavati'],  // different forms of "to be"
    ['hoti', 'honti'],    // singular vs plural
    ['ahosi', 'ahosiṁ'],  // third vs first person past
    ['pabbajati', 'pabbajiṁ'], // ordain - present vs past 1st person
    ['pabbajati', 'pabbaji'],  // ordain - present vs past 3rd person
    ['viharati', 'vihāsiṁ'],   // dwell
    ['viharati', 'viharāmi'],  // dwell - present 1st person
    ['karoti', 'akāsiṁ'],      // do - present vs past
    ['karoti', 'karoṁ'],       // do - present forms
  ];

  // Build a lookup set for quick checking
  const VERB_PAIR_SET = new Set<string>();
  for (const [a, b] of PALI_VERB_PAIRS) {
    VERB_PAIR_SET.add(`${a}|${b}`);
    VERB_PAIR_SET.add(`${b}|${a}`);
  }

  // Check if two words are similar enough to be considered a match variant
  // This catches conjugation differences like pabbajiṁ/pabbajati, ahosiṁ/hoti
  function areSimilarWords(wordA: string, wordB: string): boolean {
    if (wordA === wordB) return true;

    // Check known verb pairs first (handles irregular conjugations)
    if (VERB_PAIR_SET.has(`${wordA}|${wordB}`)) {
      return true;
    }

    // Get minimum prefix length to compare (at least 3 chars, or shorter word length)
    const minLen = Math.min(wordA.length, wordB.length);
    if (minLen < 3) return false;

    // Check for shared prefix of at least 4 chars (or 3 if words are short)
    const prefixLen = minLen < 5 ? 3 : 4;
    if (wordA.substring(0, prefixLen) === wordB.substring(0, prefixLen)) {
      return true;
    }

    // Check for shared suffix (common in verb conjugations)
    // e.g., "pativirato" and "paṭivirato" share the ending
    const suffixLen = minLen < 5 ? 2 : 3;
    if (wordA.slice(-suffixLen) === wordB.slice(-suffixLen) && minLen >= 5) {
      // Also check that the words are similar length
      if (Math.abs(wordA.length - wordB.length) <= 2) {
        return true;
      }
    }

    // Special case for Pali verb forms: check if one contains the other's root
    if (minLen >= 4) {
      // Extract likely root (first 2-3 consonants + vowel)
      const rootA = wordA.substring(0, 3);
      const rootB = wordB.substring(0, 3);
      if (wordB.includes(rootA) || wordA.includes(rootB)) {
        return true;
      }
    }

    return false;
  }

  // Extend match ranges by looking at adjacent chunks and checking match ratio
  // This captures cases where most words match but 1-2 have conjugation differences
  // Key insight: count BOTH exact matches AND similar words (conjugation variants) for extension decision
  // But only exact matches go into coveredPositions (similar words become gap words)
  // ITERATIVE: Keeps extending until we can't anymore
  function extendMatchRanges(
    sourceWords: string[],
    entryWords: string[],
    sourceRange: { startIndex: number; endIndex: number; coveredPositions: Set<number> },
    entryRange: { startIndex: number; endIndex: number; coveredPositions: Set<number> }
  ): void {
    const MIN_MATCH_RATIO = 0.70; // Require 70% of words to match (exactly or similar)
    const MAX_ITERATIONS = 20; // Prevent infinite loops

    // Helper to try extending in a direction
    function tryExtendBackward(): boolean {
      const srcWordsBeforeCount = sourceRange.startIndex;
      const entWordsBeforeCount = entryRange.startIndex;

      if (srcWordsBeforeCount <= 0 || entWordsBeforeCount <= 0) return false;

      const maxBackward = Math.min(srcWordsBeforeCount, entWordsBeforeCount, 15);

      for (let extendBy = maxBackward; extendBy >= 1; extendBy--) {
        const srcChunk = sourceWords.slice(sourceRange.startIndex - extendBy, sourceRange.startIndex);
        const entChunk = entryWords.slice(entryRange.startIndex - extendBy, entryRange.startIndex);

        if (srcChunk.length !== entChunk.length) continue;

        let exactMatches = 0;
        let similarMatches = 0;
        const exactPositions: number[] = [];
        for (let i = 0; i < srcChunk.length; i++) {
          if (srcChunk[i] === entChunk[i]) {
            exactMatches++;
            exactPositions.push(i);
          } else if (areSimilarWords(srcChunk[i], entChunk[i])) {
            similarMatches++;
          }
        }

        const totalMatches = exactMatches + similarMatches;
        const matchRatio = totalMatches / srcChunk.length;

        if (matchRatio >= MIN_MATCH_RATIO) {
          const newSrcStart = sourceRange.startIndex - extendBy;
          const newEntStart = entryRange.startIndex - extendBy;

          // Add exact match positions
          for (const relPos of exactPositions) {
            sourceRange.coveredPositions.add(newSrcStart + relPos);
            entryRange.coveredPositions.add(newEntStart + relPos);
          }

          sourceRange.startIndex = newSrcStart;
          entryRange.startIndex = newEntStart;

          // Check overall coverage
          const totalLen = sourceRange.endIndex - sourceRange.startIndex + 1;
          const overallCoverage = sourceRange.coveredPositions.size / totalLen;
          if (overallCoverage < 0.60) {
            // Revert
            sourceRange.startIndex += extendBy;
            entryRange.startIndex += extendBy;
            for (const relPos of exactPositions) {
              sourceRange.coveredPositions.delete(newSrcStart + relPos);
              entryRange.coveredPositions.delete(newEntStart + relPos);
            }
            return false;
          }
          return true; // Successfully extended
        }
      }
      return false;
    }

    function tryExtendForward(): boolean {
      const srcWordsAfterCount = sourceWords.length - 1 - sourceRange.endIndex;
      const entWordsAfterCount = entryWords.length - 1 - entryRange.endIndex;

      if (srcWordsAfterCount <= 0 || entWordsAfterCount <= 0) return false;

      const maxForward = Math.min(srcWordsAfterCount, entWordsAfterCount, 15);

      for (let extendBy = maxForward; extendBy >= 1; extendBy--) {
        const srcChunk = sourceWords.slice(sourceRange.endIndex + 1, sourceRange.endIndex + 1 + extendBy);
        const entChunk = entryWords.slice(entryRange.endIndex + 1, entryRange.endIndex + 1 + extendBy);

        if (srcChunk.length !== entChunk.length) continue;

        let exactMatches = 0;
        let similarMatches = 0;
        const exactPositions: number[] = [];
        for (let i = 0; i < srcChunk.length; i++) {
          if (srcChunk[i] === entChunk[i]) {
            exactMatches++;
            exactPositions.push(i);
          } else if (areSimilarWords(srcChunk[i], entChunk[i])) {
            similarMatches++;
          }
        }

        const totalMatches = exactMatches + similarMatches;
        const matchRatio = totalMatches / srcChunk.length;

        if (matchRatio >= MIN_MATCH_RATIO) {
          const oldSrcEnd = sourceRange.endIndex;
          const oldEntEnd = entryRange.endIndex;

          // Add exact match positions
          for (const relPos of exactPositions) {
            sourceRange.coveredPositions.add(oldSrcEnd + 1 + relPos);
            entryRange.coveredPositions.add(oldEntEnd + 1 + relPos);
          }

          sourceRange.endIndex += extendBy;
          entryRange.endIndex += extendBy;

          const totalLen = sourceRange.endIndex - sourceRange.startIndex + 1;
          const overallCoverage = sourceRange.coveredPositions.size / totalLen;
          if (overallCoverage < 0.60) {
            // Revert
            sourceRange.endIndex = oldSrcEnd;
            entryRange.endIndex = oldEntEnd;
            for (const relPos of exactPositions) {
              sourceRange.coveredPositions.delete(oldSrcEnd + 1 + relPos);
              entryRange.coveredPositions.delete(oldEntEnd + 1 + relPos);
            }
            return false;
          }
          return true; // Successfully extended
        }
      }
      return false;
    }

    // Keep extending in both directions until we can't anymore
    let iterations = 0;
    let extended = true;
    while (extended && iterations < MAX_ITERATIONS) {
      extended = false;
      if (tryExtendBackward()) extended = true;
      if (tryExtendForward()) extended = true;
      iterations++;
    }

    // Final step: Include trailing single word as gap if it's similar (conjugation variant)
    // This handles cases like pabbajiṁ vs pabbajati at sentence end
    const srcTrailing = sourceWords.length - 1 - sourceRange.endIndex;
    const entTrailing = entryWords.length - 1 - entryRange.endIndex;

    if (srcTrailing === 1 && entTrailing === 1) {
      const srcWord = sourceWords[sourceRange.endIndex + 1];
      const entWord = entryWords[entryRange.endIndex + 1];

      // If the trailing words are similar (same stem/root), include as gap
      if (areSimilarWords(srcWord, entWord)) {
        sourceRange.endIndex += 1;
        entryRange.endIndex += 1;
        // Don't add to coveredPositions - these are gap words
      }
    }
  }

  // Type for source range candidate (used by multi-match)
  type SourceRangeCandidate = {
    startIndex: number;
    endIndex: number;
    matchedWords: string[];
    contentWordCount: number;
    coveredPositions: Set<number>;
    coverageRatio: number;
  };

  // Check if two ranges have significant overlap (>= threshold)
  function rangesOverlap(a: SourceRangeCandidate, b: SourceRangeCandidate, threshold: number = 0.9): boolean {
    const aPositions = new Set<number>();
    for (let i = a.startIndex; i <= a.endIndex; i++) aPositions.add(i);

    const bPositions = new Set<number>();
    for (let i = b.startIndex; i <= b.endIndex; i++) bPositions.add(i);

    // Count overlap
    let overlap = 0;
    for (const pos of aPositions) {
      if (bPositions.has(pos)) overlap++;
    }

    // Check if overlap is >= threshold of the smaller range
    const smallerSize = Math.min(aPositions.size, bPositions.size);
    return overlap / smallerSize >= threshold;
  }

  // Compute which source words are covered by matched ngrams
  // Returns the BEST contiguous run of covered indices (not spanning across gaps)
  // Get preliminary word range from n-gram matches
  // Returns range even if coverage is low - caller should do stem matching to boost coverage
  function getSourceWordRange(queryWords: string[], matchedNgrams: Set<string>, ngramSize: number): {
    startIndex: number;
    endIndex: number;
    matchedWords: string[];
    contentWordCount: number;
    coveredPositions: Set<number>; // Which word positions are actually covered by n-grams
    coverageRatio: number; // For debugging
  } | null {
    if (matchedNgrams.size === 0) return null;

    // Find all contiguous runs where ngrams match
    // A run is a sequence of overlapping ngram matches
    const queryNgrams = extractNgrams(queryWords, ngramSize);

    // Find positions where matching ngrams START
    const matchPositions: number[] = [];
    for (let i = 0; i < queryNgrams.length; i++) {
      if (matchedNgrams.has(queryNgrams[i])) {
        matchPositions.push(i);
      }
    }

    if (matchPositions.length === 0) return null;

    // Gap tolerance: allow for word differences in matches
    const maxGapPositions = ngramSize + 2;

    // Group into contiguous runs
    const runs: Array<{ start: number; end: number }> = [];
    let currentRun = { start: matchPositions[0], end: matchPositions[0] + ngramSize - 1 };

    for (let i = 1; i < matchPositions.length; i++) {
      const pos = matchPositions[i];
      if (pos <= currentRun.end + maxGapPositions) {
        currentRun.end = Math.max(currentRun.end, pos + ngramSize - 1);
      } else {
        runs.push(currentRun);
        currentRun = { start: pos, end: pos + ngramSize - 1 };
      }
    }
    runs.push(currentRun);

    // Helper to calculate coverage for a given range
    const calculateRunCoverage = (run: { start: number; end: number }) => {
      const covered = new Set<number>();
      for (const pos of matchPositions) {
        if (pos >= run.start && pos + ngramSize - 1 <= run.end) {
          for (let j = pos; j < pos + ngramSize; j++) {
            covered.add(j);
          }
        }
      }
      const len = run.end - run.start + 1;
      const words = queryWords.slice(run.start, run.end + 1);
      const contentCount = words.filter(w => !isStopWord(w)).length;
      return { covered, coverage: covered.size / len, contentCount, words };
    };

    // Strategy: Pick the best run, not merge all runs
    // "Best" = highest content word count among runs with good coverage (>= 60%)
    // If no single run has good coverage, try merging adjacent runs
    const MIN_RUN_COVERAGE = 0.60;

    // Evaluate each run
    const runEvaluations = runs.map((run, idx) => {
      const { covered, coverage, contentCount, words } = calculateRunCoverage(run);
      return { run, idx, covered, coverage, contentCount, words };
    });

    // Find runs with acceptable coverage, sorted by content word count (descending)
    const goodRuns = runEvaluations
      .filter(r => r.coverage >= MIN_RUN_COVERAGE)
      .sort((a, b) => b.contentCount - a.contentCount);

    let bestRun: { start: number; end: number };
    let coveredPositions: Set<number>;
    let matchedWords: string[];
    let contentWordCount: number;
    let coverageRatio: number;

    if (goodRuns.length > 0) {
      // Use the best single run
      const best = goodRuns[0];
      bestRun = best.run;
      coveredPositions = best.covered;
      matchedWords = best.words;
      contentWordCount = best.contentCount;
      coverageRatio = best.coverage;
    } else {
      // No single run has good coverage - fall back to merged approach
      // but be more conservative: only merge if coverage stays reasonable
      const mergedRun = {
        start: runs[0].start,
        end: runs[runs.length - 1].end,
      };
      const { covered, coverage, contentCount, words } = calculateRunCoverage(mergedRun);

      // If merged coverage is still poor, pick the largest single run anyway
      if (coverage < 0.40) {
        // Pick run with most content words regardless of coverage
        const largest = runEvaluations.sort((a, b) => b.contentCount - a.contentCount)[0];
        bestRun = largest.run;
        coveredPositions = largest.covered;
        matchedWords = largest.words;
        contentWordCount = largest.contentCount;
        coverageRatio = largest.coverage;
      } else {
        bestRun = mergedRun;
        coveredPositions = covered;
        matchedWords = words;
        contentWordCount = contentCount;
        coverageRatio = coverage;
      }
    }

    return {
      startIndex: bestRun.start,
      endIndex: bestRun.end,
      matchedWords,
      contentWordCount,
      coveredPositions,
      coverageRatio,
    };
  }

  // Multi-match version: Return ALL non-overlapping runs with good coverage
  // This allows a single entry to match multiple distinct regions of the source
  // Overlap threshold: 90% means runs must be < 90% overlapping to be kept as separate
  function getSourceWordRanges(queryWords: string[], matchedNgrams: Set<string>, ngramSize: number): SourceRangeCandidate[] {
    if (matchedNgrams.size === 0) return [];

    const MULTI_MATCH_OVERLAP_THRESHOLD = 0.90; // Runs with >= 90% overlap are considered duplicates

    // Find all contiguous runs where ngrams match
    const queryNgrams = extractNgrams(queryWords, ngramSize);

    // Find positions where matching ngrams START
    const matchPositions: number[] = [];
    for (let i = 0; i < queryNgrams.length; i++) {
      if (matchedNgrams.has(queryNgrams[i])) {
        matchPositions.push(i);
      }
    }

    if (matchPositions.length === 0) return [];

    // Gap tolerance: allow for word differences in matches
    const maxGapPositions = ngramSize + 2;

    // Group into contiguous runs
    const runs: Array<{ start: number; end: number }> = [];
    let currentRun = { start: matchPositions[0], end: matchPositions[0] + ngramSize - 1 };

    for (let i = 1; i < matchPositions.length; i++) {
      const pos = matchPositions[i];
      if (pos <= currentRun.end + maxGapPositions) {
        currentRun.end = Math.max(currentRun.end, pos + ngramSize - 1);
      } else {
        runs.push(currentRun);
        currentRun = { start: pos, end: pos + ngramSize - 1 };
      }
    }
    runs.push(currentRun);

    // Helper to calculate coverage for a given range
    const calculateRunCoverage = (run: { start: number; end: number }) => {
      const covered = new Set<number>();
      for (const pos of matchPositions) {
        if (pos >= run.start && pos + ngramSize - 1 <= run.end) {
          for (let j = pos; j < pos + ngramSize; j++) {
            covered.add(j);
          }
        }
      }
      const len = run.end - run.start + 1;
      const words = queryWords.slice(run.start, run.end + 1);
      const contentCount = words.filter(w => !isStopWord(w)).length;
      return { covered, coverage: covered.size / len, contentCount, words };
    };

    const MIN_RUN_COVERAGE = 0.60;

    // Evaluate each run
    const runEvaluations = runs.map((run, idx) => {
      const { covered, coverage, contentCount, words } = calculateRunCoverage(run);
      return { run, idx, covered, coverage, contentCount, words };
    });

    // Find runs with acceptable coverage
    const goodRuns = runEvaluations
      .filter(r => r.coverage >= MIN_RUN_COVERAGE && r.contentCount >= 2)
      .sort((a, b) => b.contentCount - a.contentCount); // Prefer longer matches

    // Convert to SourceRangeCandidate format
    const candidates: SourceRangeCandidate[] = goodRuns.map(r => ({
      startIndex: r.run.start,
      endIndex: r.run.end,
      matchedWords: r.words,
      contentWordCount: r.contentCount,
      coveredPositions: r.covered,
      coverageRatio: r.coverage,
    }));

    // Filter out overlapping ranges (keep the ones with more content words)
    const nonOverlapping: SourceRangeCandidate[] = [];
    for (const candidate of candidates) {
      // Check if this candidate overlaps significantly with any already-kept candidate
      const overlapsWithExisting = nonOverlapping.some(existing =>
        rangesOverlap(candidate, existing, MULTI_MATCH_OVERLAP_THRESHOLD)
      );

      if (!overlapsWithExisting) {
        nonOverlapping.push(candidate);
      }
    }

    if ((window as any).tmDebugVerbose && nonOverlapping.length > 1) {
      console.log(`[TM Debug] Multi-match: found ${nonOverlapping.length} distinct regions:`,
        nonOverlapping.map(r => `${r.startIndex}-${r.endIndex} (${r.contentWordCount} content words)`));
    }

    return nonOverlapping;
  }

  // Boost coverage by checking stem similarity for uncovered positions
  // This catches conjugation variants like ahosiṁ/hoti, pakkamiṁ/pakkamati
  function boostCoverageWithStemMatching(
    sourceWords: string[],
    entryWords: string[],
    sourceRange: { startIndex: number; endIndex: number; coveredPositions: Set<number>; coverageRatio: number },
    entryRange: { startIndex: number; endIndex: number; coveredPositions: Set<number>; coverageRatio: number }
  ): { sourceCoverage: number; entryCoverage: number } {
    const sourceLen = sourceRange.endIndex - sourceRange.startIndex + 1;
    const entryLen = entryRange.endIndex - entryRange.startIndex + 1;

    // Clone covered positions so we can add stem matches
    const sourceCovered = new Set(sourceRange.coveredPositions);
    const entryCovered = new Set(entryRange.coveredPositions);

    // Check uncovered positions for stem similarity
    for (let i = 0; i < sourceLen; i++) {
      const srcPos = sourceRange.startIndex + i;
      const entPos = entryRange.startIndex + i;

      // Skip if already covered or out of bounds
      if (sourceCovered.has(srcPos)) continue;
      if (entPos > entryRange.endIndex) continue;

      const srcWord = sourceWords[srcPos];
      const entWord = entryWords[entPos];

      if (!srcWord || !entWord) continue;

      // Check if words are similar (same stem, conjugation variants, etc.)
      if (areSimilarWords(srcWord, entWord)) {
        sourceCovered.add(srcPos);
        entryCovered.add(entPos);

        if ((window as any).tmDebugVerbose) {
          console.log(`[TM Debug] Stem match: "${srcWord}" ~ "${entWord}" at positions ${srcPos}/${entPos}`);
        }
      }
    }

    // Update the ranges with boosted covered positions
    sourceRange.coveredPositions = sourceCovered;
    entryRange.coveredPositions = entryCovered;

    const sourceCoverage = sourceCovered.size / sourceLen;
    const entryCoverage = entryCovered.size / entryLen;

    return { sourceCoverage, entryCoverage };
  }

  // Find partial matches using n-gram index
  function findNgramMatches(queryWords: string[], currentSuttaId?: string): Map<number, Set<string>> {
    if (!tmIndex || !tmIndex.ngrams) return new Map();

    const ngramSize = tmIndex.ngramSize || 5;
    const queryNgrams = extractNgrams(queryWords, ngramSize);

    // Map entry ID -> matched n-grams
    const entryMatches = new Map<number, Set<string>>();

    for (const ngram of queryNgrams) {
      const entryIds = tmIndex.ngrams[ngram];
      if (!entryIds) continue;

      for (const id of entryIds) {
        // Note: We now allow same-discourse matching for internal consistency checking
        const entry = tmIndex.entries[id];

        if (!entryMatches.has(id)) {
          entryMatches.set(id, new Set());
        }
        entryMatches.get(id)!.add(ngram);
      }
    }

    return entryMatches;
  }

  // Find multiple matches for a Pali paragraph
  // sourceRef: optional reference to the source paragraph for display in popover
  function findMatches(queryPali: string, queryPaliOriginal: string, currentSuttaId?: string, sourceRef?: { suttaId: string; paragraphNum: number }): TMMatchResult | null {
    if (!tmIndex || tmIndex.entries.length === 0) return null;

    const queryNormalized = normalizePali(queryPali);
    const queryWords = queryNormalized.split(/\s+/).filter(w => w.length > 0);

    // Also extract words using the same method as entry words (for extension)
    // This ensures consistent word comparison during range extension
    const queryWordsForExtension = extractWordsForHighlight(queryPaliOriginal);

    if (queryWords.length < 4) return null;

    // Collect all matches with their details
    const allMatches: Array<{
      entry: TMEntry;
      score: number;
      matchedWordCount: number;
      contentWordCount: number;
      matchedWords: Set<string>;
      matchedSegment: string;
      startIndex: number;
      endIndex: number;
      coveredPositions: Set<number>;   // Covered positions in source text
      entryStartIndex: number;  // Position in entry text
      entryEndIndex: number;    // Position in entry text
      entryCoveredPositions: Set<number>; // Covered positions in entry text
    }> = [];

    // Step 1: Use n-gram index to find candidate entries with shared phrases
    const ngramMatches = findNgramMatches(queryWords, currentSuttaId);

    // Step 2: For entries with n-gram matches, compute detailed match
    // Now supports MULTIPLE matches per entry for distinct regions
    for (const [entryId, matchedNgrams] of ngramMatches) {
      const entry = tmIndex.entries[entryId];
      if (!entry) continue;

      // Skip the exact same paragraph (same suttaId AND same paragraphNum)
      if (sourceRef && entry.source.suttaId === sourceRef.suttaId && entry.source.paragraphNum === sourceRef.paragraphNum) {
        continue;
      }

      const ngramSize = tmIndex.ngramSize || 5;

      // Also get which ENTRY words are covered by the matched ngrams
      // IMPORTANT: Use paliOriginal with same word extraction as rendering to ensure positions align
      const entryWords = extractWordsForHighlight(entry.paliOriginal);

      // Check n-gram order consistency: skip matches where words appear in different order
      if (!checkNgramOrderConsistency(queryWords, entryWords, matchedNgrams, ngramSize)) {
        if ((window as any).tmDebugVerbose) {
          console.log(`[TM Debug] Entry ${entryId} (${entry.source.suttaId}.${entry.source.paragraphNum}) REJECTED: n-gram order inconsistent`);
        }
        continue;
      }

      // Get ALL distinct regions this entry matches in the source (multi-match support)
      const sourceRanges = getSourceWordRanges(queryWords, matchedNgrams, ngramSize);
      const entryRanges = getSourceWordRanges(entryWords, matchedNgrams, ngramSize);

      // If no valid ranges, skip
      if (sourceRanges.length === 0 || entryRanges.length === 0) {
        if ((window as any).tmDebugVerbose) {
          console.log(`[TM Debug] Entry ${entryId} (${entry.source.suttaId}.${entry.source.paragraphNum}) REJECTED: no valid ranges`);
        }
        continue;
      }

      // Process each source range as a potential match
      // For each source range, find the best matching entry range by N-GRAM OVERLAP
      for (const sourceRange of sourceRanges) {
        if (sourceRange.contentWordCount < 2) continue;

        // Get the n-grams that are covered by this source range
        const sourceRangeNgrams = new Set<string>();
        const sourceNgrams = extractNgrams(queryWords, ngramSize);
        for (let i = sourceRange.startIndex; i <= sourceRange.endIndex - ngramSize + 1; i++) {
          if (matchedNgrams.has(sourceNgrams[i])) {
            sourceRangeNgrams.add(sourceNgrams[i]);
          }
        }

        // Find the entry range with the most n-gram overlap with this source range
        let bestEntryRange = entryRanges[0];
        let bestOverlap = 0;

        const entryNgrams = extractNgrams(entryWords, ngramSize);
        for (const entryRange of entryRanges) {
          // Count n-grams in this entry range that are also in source range
          let overlap = 0;
          for (let i = entryRange.startIndex; i <= entryRange.endIndex - ngramSize + 1; i++) {
            if (sourceRangeNgrams.has(entryNgrams[i])) {
              overlap++;
            }
          }
          if (overlap > bestOverlap) {
            bestOverlap = overlap;
            bestEntryRange = entryRange;
          }
        }

        // Clone the best entry range for modification
        const entryRange = { ...bestEntryRange };

        // Boost coverage by checking stem similarity for uncovered positions
        // This catches conjugation variants like ahosiṁ/hoti, pakkamiṁ/pakkamati
        const workingSourceRange = { ...sourceRange, coveredPositions: new Set(sourceRange.coveredPositions) };
        const workingEntryRange = { ...entryRange, coveredPositions: new Set(entryRange.coveredPositions) };

        const { sourceCoverage, entryCoverage } = boostCoverageWithStemMatching(
          queryWords, entryWords, workingSourceRange, workingEntryRange
        );

        if ((window as any).tmDebugVerbose) {
          console.log(`[TM Debug] Entry ${entryId} (${entry.source.suttaId}.${entry.source.paragraphNum}) range ${sourceRange.startIndex}-${sourceRange.endIndex}:`, {
            matchedNgramsCount: matchedNgrams.size,
            sourceRange: { start: sourceRange.startIndex, end: sourceRange.endIndex, initialCoverage: sourceRange.coverageRatio.toFixed(2), boostedCoverage: sourceCoverage.toFixed(2) },
            entryRange: { start: entryRange.startIndex, end: entryRange.endIndex, initialCoverage: entryRange.coverageRatio.toFixed(2), boostedCoverage: entryCoverage.toFixed(2) },
          });
        }

        // Apply 80% threshold after stem matching boost
        if (sourceCoverage < 0.8 || entryCoverage < 0.8) {
          if ((window as any).tmDebugVerbose) {
            console.log(`[TM Debug] Entry ${entryId} range ${sourceRange.startIndex}-${sourceRange.endIndex} REJECTED: coverage below 80% after stem matching`);
          }
          continue;
        }

        // Only extend if word arrays are aligned (same length)
        // This ensures indices are valid across both arrays
        const canExtend = queryWords.length === queryWordsForExtension.length;

        if (canExtend) {
          // Extend ranges to capture adjacent words with conjugation differences
          // This catches cases like pabbajiṁ/pabbajati, ahosiṁ/hoti at phrase boundaries
          extendMatchRanges(queryWordsForExtension, entryWords, workingSourceRange, workingEntryRange);
        }

        // Update matchedWords after extension
        const wordsForSlice = canExtend ? queryWordsForExtension : queryWords;
        workingSourceRange.matchedWords = wordsForSlice.slice(workingSourceRange.startIndex, workingSourceRange.endIndex + 1);

        // Score based on coverage: how much of the source phrase is matched
        const ngramBoost = matchedNgrams.size >= 3 ? 1.0 : matchedNgrams.size / 3;

        allMatches.push({
          entry,
          score: ngramBoost,
          matchedWordCount: workingSourceRange.matchedWords.length, // Segment length (may include repeated words)
          contentWordCount: workingSourceRange.contentWordCount,
          matchedWords: new Set(workingSourceRange.matchedWords),
          matchedSegment: workingSourceRange.matchedWords.join(' '), // Store actual segment for debugging
          startIndex: workingSourceRange.startIndex,
          endIndex: workingSourceRange.endIndex,
          coveredPositions: workingSourceRange.coveredPositions,
          entryStartIndex: workingEntryRange.startIndex,
          entryEndIndex: workingEntryRange.endIndex,
          entryCoveredPositions: workingEntryRange.coveredPositions,
        });

        if ((window as any).tmDebugVerbose) {
          console.log(`[TM Debug] Entry ${entryId} ACCEPTED: added to allMatches`, {
            suttaId: entry.source.suttaId,
            paragraphNum: entry.source.paragraphNum,
            matchedSegment: workingSourceRange.matchedWords.join(' ').substring(0, 60) + '...',
            wordRange: `${workingSourceRange.startIndex}-${workingSourceRange.endIndex}`,
            contentWordCount: workingSourceRange.contentWordCount,
          });
        }
      }
    }

    // Step 3: Also check entries without n-gram matches but potential contiguous matches
    // (for short entries that might not have enough n-grams)
    for (const entry of tmIndex.entries) {
      // Skip the exact same paragraph (same suttaId AND same paragraphNum)
      if (sourceRef && entry.source.suttaId === sourceRef.suttaId && entry.source.paragraphNum === sourceRef.paragraphNum) {
        continue;
      }

      // Skip if already processed via n-gram
      if (ngramMatches.has(entry.id)) continue;

      // Only check short entries (might match via contiguous but not have n-grams)
      if (entry.wordCount > 10) continue;

      const entryWords = entry.paliNormalized.split(/\s+/).filter(w => w.length > 0);

      // Find contiguous match
      const match = findContiguousMatch(entryWords, queryWords);

      if (match && match.score >= THRESHOLDS.PARAGRAPH_SIMILARITY && match.contentWordCount >= 2) {
        // For short entries, the match covers the whole entry
        // Use original text word count for proper highlighting
        const originalWords = extractWordsForHighlight(entry.paliOriginal);
        // For short entries, assume all positions are covered (no gaps)
        const allCovered = new Set<number>();
        for (let i = match.startIndex; i <= match.endIndex; i++) allCovered.add(i);
        const entryCovered = new Set<number>();
        for (let i = 0; i < originalWords.length; i++) entryCovered.add(i);

        allMatches.push({
          entry,
          score: match.score,
          matchedWordCount: match.matchedWords.length, // Segment length
          contentWordCount: match.contentWordCount,
          matchedWords: new Set(match.matchedWords),
          matchedSegment: match.matchedWords.join(' '),
          startIndex: match.startIndex,
          endIndex: match.endIndex,
          coveredPositions: allCovered,
          entryStartIndex: 0,
          entryEndIndex: originalWords.length - 1,
          entryCoveredPositions: entryCovered,
        });
      }
    }

    if (allMatches.length === 0) return null;

    // Sort by content word count first, then by score
    allMatches.sort((a, b) => {
      if (b.contentWordCount !== a.contentWordCount) {
        return b.contentWordCount - a.contentWordCount;
      }
      return b.score - a.score;
    });

    // Group by matched phrase from the SOURCE QUERY (not entry text)
    // This ensures entries matching the same source words are grouped together,
    // and entries matching different source regions form separate groups
    // Key: sorted matched words (the actual phrase pattern from the source)
    const phraseMap = new Map<string, {
      score: number;
      contentWordCount: number; // For internal sorting/matching
      totalWordCount: number;   // For display (includes stop words)
      matchedWords: Set<string>;
      matchedSegment: string;   // The actual matched segment text
      startIndex: number; // Source position range
      endIndex: number;
      coveredPositions: Set<number>; // Which positions are actually covered (not gaps)
      discourses: TMDiscourse[];
      totalCount: number; // Count all matches, even if not stored
    }>();

    for (const m of allMatches) {
      // Group by CONTENT words only (excluding stop words) for consistency
      // This ensures phrases that differ only by stop words (like "ime kho") are grouped together
      // Also include content word count to prevent grouping matches of vastly different lengths
      const contentWordsOnly = [...m.matchedWords].filter(w => !isStopWord(w)).sort();
      // Round content word count to buckets of 10 to allow minor variations in same group
      const countBucket = Math.floor(m.contentWordCount / 10) * 10;
      const phraseKey = `${countBucket}:${contentWordsOnly.join(' ')}`;

      const isNewGroup = !phraseMap.has(phraseKey);

      if ((window as any).tmDebugVerbose && m.entry.source.suttaId === 'ud7.9') {
        console.log(`[TM Debug] Grouping ud7.9.${m.entry.source.paragraphNum}:`, {
          phraseKey: phraseKey.substring(0, 80) + '...',
          isNewGroup,
          contentWordCount: m.contentWordCount,
          wordRange: `${m.startIndex}-${m.endIndex}`,
        });
      }

      if (isNewGroup) {
        phraseMap.set(phraseKey, {
          score: m.score,
          contentWordCount: m.contentWordCount,
          totalWordCount: m.matchedWordCount, // Total words for display (segment length)
          matchedWords: m.matchedWords,
          matchedSegment: m.matchedSegment, // Store segment text for debugging
          startIndex: m.startIndex,
          endIndex: m.endIndex,
          coveredPositions: m.coveredPositions, // Which positions in source are covered
          discourses: [],
          totalCount: 0,
        });
      }

      const group = phraseMap.get(phraseKey)!;

      // Filter out discourses with significantly fewer matched words (subset matches)
      // Allow up to 10% fewer words, otherwise reject as a subset match
      const minAllowedWords = Math.floor(group.contentWordCount * 0.9);
      if (m.contentWordCount < minAllowedWords) {
        if ((window as any).tmDebugVerbose && m.entry.source.suttaId === 'ud7.9') {
          console.log(`[TM Debug] ud7.9.${m.entry.source.paragraphNum} FILTERED as subset:`, {
            matchContentWords: m.contentWordCount,
            groupContentWords: group.contentWordCount,
            minRequired: minAllowedWords,
          });
        }
        continue; // Skip this discourse - it's a subset match
      }

      // Deduplicate: skip if this exact suttaId+paragraphNum is already in the group
      // This happens when the source paragraph repeats the same phrase multiple times,
      // causing the same entry to match at multiple source positions
      const discourseKey = `${m.entry.source.suttaId}.${m.entry.source.paragraphNum}`;
      const alreadyInGroup = group.discourses.some(
        d => `${d.suttaId}.${d.paragraphNum}` === discourseKey
      );

      if (alreadyInGroup) continue;

      group.totalCount++; // Count only unique, non-subset matches

      // Only store up to MAX for diversity selection
      if (group.discourses.length < THRESHOLDS.MAX_DISCOURSES_TO_STORE) {
        group.discourses.push({
          suttaId: m.entry.source.suttaId,
          paragraphNum: m.entry.source.paragraphNum,
          collection: m.entry.source.collection,
          paliOriginal: m.entry.paliOriginal,
          englishOriginal: m.entry.englishOriginal,
          matchedWords: m.matchedWords, // Store per-discourse matched words
          contentWordCount: m.contentWordCount, // Store per-discourse content word count
          entryStartIndex: m.entryStartIndex, // Position in entry text
          entryEndIndex: m.entryEndIndex,     // Position in entry text
          entryCoveredPositions: m.entryCoveredPositions, // Which positions in entry are covered
        });
      }
    }

    // Convert to array, sorted by content word count (larger matches first)
    const sortedGroups = Array.from(phraseMap.entries())
      .sort((a, b) => b[1].contentWordCount - a[1].contentWordCount || b[1].score - a[1].score);

    // Helper: check if two sets are equal
    function setsEqual(setA: Set<string>, setB: Set<string>): boolean {
      if (setA.size !== setB.size) return false;
      for (const item of setA) {
        if (!setB.has(item)) return false;
      }
      return true;
    }

    // Helper: check if setA's content words are a subset of setB's content words
    function isContentWordSubset(setA: Set<string>, setB: Set<string>): boolean {
      const contentA = [...setA].filter(w => !isStopWord(w));
      const contentB = [...setB].filter(w => !isStopWord(w));
      if (contentA.length >= contentB.length) return false; // Must be strictly smaller
      for (const word of contentA) {
        if (!setB.has(word)) return false;
      }
      return true;
    }

    // Helper: check if range A is a subset of range B (with tolerance for 1-2 word difference)
    // This handles cases where a shorter match differs only by a gap word from a longer match
    function isRangeSubset(
      rangeA: { startIndex?: number; endIndex?: number },
      rangeB: { startIndex?: number; endIndex?: number }
    ): boolean {
      if (rangeA.startIndex === undefined || rangeA.endIndex === undefined ||
          rangeB.startIndex === undefined || rangeB.endIndex === undefined) {
        return false;
      }
      const lenA = rangeA.endIndex - rangeA.startIndex + 1;
      const lenB = rangeB.endIndex - rangeB.startIndex + 1;

      // A must be smaller
      if (lenA >= lenB) return false;

      // A's range must be mostly contained in B's range
      // Allow for slight offset (1-2 words) at start/end
      const startDiff = rangeA.startIndex - rangeB.startIndex;
      const endDiff = rangeB.endIndex - rangeA.endIndex;

      // Both differences should be non-negative (A is inside B) or very small negative
      return startDiff >= -1 && endDiff >= -1 && (startDiff + endDiff >= 0);
    }

    // Helper: check if two phrase groups are highly similar (overlap by 1 word or 90%+ similar)
    // This helps deduplicate phrase groups that are essentially the same match
    function isHighlyOverlapping(
      groupA: { startIndex?: number; endIndex?: number; matchedWords: Set<string> },
      groupB: { startIndex?: number; endIndex?: number; matchedWords: Set<string> }
    ): boolean {
      // Check range overlap first
      if (groupA.startIndex === undefined || groupA.endIndex === undefined ||
          groupB.startIndex === undefined || groupB.endIndex === undefined) {
        return false;
      }

      // If ranges don't overlap at all, not similar
      const overlapStart = Math.max(groupA.startIndex, groupB.startIndex);
      const overlapEnd = Math.min(groupA.endIndex, groupB.endIndex);
      if (overlapEnd < overlapStart) return false; // No range overlap

      // Calculate position-based overlap ratio
      // If 50%+ of the smaller group's positions are within the larger group, consider overlapping
      const lenA = groupA.endIndex - groupA.startIndex + 1;
      const lenB = groupB.endIndex - groupB.startIndex + 1;
      const overlapLen = overlapEnd - overlapStart + 1;
      const smallerLen = Math.min(lenA, lenB);
      const positionOverlapRatio = overlapLen / smallerLen;

      // If position overlap is 80%+, consider highly overlapping
      if (positionOverlapRatio >= 0.8) {
        return true;
      }

      // Calculate Jaccard similarity of content words
      const contentA = [...groupA.matchedWords].filter(w => !isStopWord(w));
      const contentB = [...groupB.matchedWords].filter(w => !isStopWord(w));

      const setA = new Set(contentA);
      const setB = new Set(contentB);

      // Count intersection
      let intersection = 0;
      for (const word of setA) {
        if (setB.has(word)) intersection++;
      }

      // Union size
      const union = new Set([...contentA, ...contentB]).size;
      if (union === 0) return false;

      const jaccardSimilarity = intersection / union;

      // Check if difference is just 1 word
      const diffSize = Math.abs(setA.size - setB.size);
      const uniqueToA = contentA.filter(w => !setB.has(w)).length;
      const uniqueToB = contentB.filter(w => !setA.has(w)).length;
      const totalDiff = uniqueToA + uniqueToB;

      // Consider highly overlapping if:
      // 1. 90%+ Jaccard similarity, OR
      // 2. Differ by at most 1 content word total
      return jaccardSimilarity >= 0.9 || totalDiff <= 1;
    }

    // Filter out phrase groups that are subsets OR equal to existing groups
    // For equal groups, merge their discourses and counts into the first one
    // For pure subsets, skip them entirely (don't display redundant smaller matches)
    const phraseGroups: TMPhraseGroup[] = [];

    if ((window as any).tmDebugVerbose) {
      console.log(`[TM Debug] Filtering ${sortedGroups.length} sorted groups into phrase groups...`);
    }

    for (const [phraseNormalized, data] of sortedGroups) {
      // Check if this group's content words are a PURE SUBSET of any already-added group
      // If so, skip it entirely - the larger group already covers these words
      const isPureSubset = phraseGroups.some(existing =>
        isContentWordSubset(data.matchedWords, existing.matchedWords) ||
        isRangeSubset(data, existing)
      );

      if (isPureSubset) {
        if ((window as any).tmDebugVerbose) {
          console.log(`[TM Debug] Group SKIPPED (pure subset):`, {
            wordRange: `${data.startIndex}-${data.endIndex}`,
            contentWords: data.contentWordCount,
            segment: data.matchedSegment.substring(0, 50) + '...',
          });
        }
        // Skip this group - it's a pure subset of a larger match
        continue;
      }

      // Check if this group is highly overlapping with an existing group (90%+ similar or differ by 1 word)
      // If so, merge into the existing group (prefer the larger/first one)
      // Also check if existing is a subset of this new group (new is superset)
      const overlappingGroup = phraseGroups.find(existing =>
        isHighlyOverlapping(data, existing) || isRangeSubset(existing, data)
      );

      if (overlappingGroup) {
        if ((window as any).tmDebugVerbose) {
          console.log(`[TM Debug] Group MERGED into existing:`, {
            newRange: `${data.startIndex}-${data.endIndex}`,
            existingRange: `${overlappingGroup.startIndex}-${overlappingGroup.endIndex}`,
            newContentWords: data.contentWordCount,
            existingContentWords: overlappingGroup.contentWordCount,
          });
        }
        // Merge into the existing overlapping group
        // If new group is larger (superset), update the group's range
        if (data.startIndex !== undefined && data.endIndex !== undefined &&
            overlappingGroup.startIndex !== undefined && overlappingGroup.endIndex !== undefined) {
          const newLen = data.endIndex - data.startIndex + 1;
          const existingLen = overlappingGroup.endIndex - overlappingGroup.startIndex + 1;
          if (newLen > existingLen) {
            // New group is larger - update the group to use new range
            overlappingGroup.startIndex = data.startIndex;
            overlappingGroup.endIndex = data.endIndex;
            overlappingGroup.matchedSegment = data.matchedSegment;
            overlappingGroup.matchedWordCount = data.totalWordCount;
            overlappingGroup.matchedWords = data.matchedWords;
            overlappingGroup.coveredPositions = data.coveredPositions;
          }
        }
        overlappingGroup.totalCount += data.totalCount;
        for (const d of data.discourses) {
          if (overlappingGroup.discourses.length < THRESHOLDS.MAX_DISCOURSES_TO_STORE) {
            overlappingGroup.discourses.push(d);
          }
        }
        overlappingGroup.diverseDiscourses = selectDiverseDiscourses(overlappingGroup.discourses, 3);
        continue;
      }

      // Check if this group is EQUAL to an existing group (same matched words)
      // If so, merge their discourses together
      const existingMatch = phraseGroups.find(existing =>
        setsEqual(data.matchedWords, existing.matchedWords)
      );

      if (existingMatch) {

        // Merge into existing group
        existingMatch.totalCount += data.totalCount; // Merge counts

        // Add discourses for diversity (up to limit)
        for (const d of data.discourses) {
          if (existingMatch.discourses.length < THRESHOLDS.MAX_DISCOURSES_TO_STORE) {
            existingMatch.discourses.push(d);
          }
        }
        // Update diverse discourses
        existingMatch.diverseDiscourses = selectDiverseDiscourses(existingMatch.discourses, 3);
        continue;
      }

      if (phraseGroups.length < THRESHOLDS.MAX_PHRASE_GROUPS) {
        // Apply diversity logic: prefer discourses from different collections
        const diverseDiscourses = selectDiverseDiscourses(data.discourses, 3);

        if ((window as any).tmDebugVerbose) {
          console.log(`[TM Debug] Group ADDED as new phrase group #${phraseGroups.length + 1}:`, {
            wordRange: `${data.startIndex}-${data.endIndex}`,
            contentWords: data.contentWordCount,
            segment: data.matchedSegment.substring(0, 50) + '...',
            discourses: data.totalCount,
          });
        }

        phraseGroups.push({
          phraseNormalized,
          similarity: data.score,
          score: data.score, // Include score for debug output
          matchedWordCount: data.totalWordCount, // Total words for display (segment length)
          contentWordCount: data.contentWordCount, // Content words (non-stop words)
          matchedWords: data.matchedWords,
          matchedSegment: data.matchedSegment, // The actual matched segment
          startIndex: data.startIndex,
          endIndex: data.endIndex,
          coveredPositions: data.coveredPositions, // Which positions in source are covered (not gaps)
          discourses: data.discourses, // Stored for diversity selection
          totalCount: data.totalCount, // True count of all matches
          diverseDiscourses, // Top 3 diverse discourses for display
        });
      }
    }

    // Calculate total UNIQUE discourses across all phrase groups
    // A discourse appearing in multiple phrase groups is counted only once
    const allDiscourseIds = new Set<string>();
    for (const pg of phraseGroups) {
      for (const d of pg.discourses) {
        allDiscourseIds.add(`${d.suttaId}.${d.paragraphNum}`);
      }
    }
    const totalDiscourses = allDiscourseIds.size;

    // Sort phrase groups by position in source text (ascending startIndex)
    // This shows matches in the order they appear in the source paragraph
    phraseGroups.sort((a, b) => (a.startIndex ?? 0) - (b.startIndex ?? 0));

    return {
      phraseGroups,
      sourcePali: queryPaliOriginal,
      totalDiscourses,
      sourceWordCount: queryWords.length, // Total words for display (users can count and verify)
      sourceRef, // Source paragraph reference for display
    };
  }

  // Select diverse discourses from different suttas (not just collections)
  function selectDiverseDiscourses(discourses: TMDiscourse[], count: number): TMDiscourse[] {
    if (discourses.length <= count) return discourses;

    const selected: TMDiscourse[] = [];
    const seenSuttas = new Set<string>();
    const seenCollections = new Set<string>();

    // First pass: pick one from each unique sutta
    for (const d of discourses) {
      if (selected.length >= count) break;
      if (!seenSuttas.has(d.suttaId)) {
        selected.push(d);
        seenSuttas.add(d.suttaId);
        seenCollections.add(d.collection);
      }
    }

    // Second pass: if still need more, pick from different collections
    for (const d of discourses) {
      if (selected.length >= count) break;
      if (!seenSuttas.has(d.suttaId) && !seenCollections.has(d.collection)) {
        selected.push(d);
        seenSuttas.add(d.suttaId);
        seenCollections.add(d.collection);
      }
    }

    // Third pass: fill remaining slots with any discourses not yet selected
    for (const d of discourses) {
      if (selected.length >= count) break;
      if (!selected.includes(d)) {
        selected.push(d);
      }
    }

    return selected;
  }

  // Render Pali text with clickable word spans for dictionary lookup
  // Three modes:
  // 1. matchedWords (Set) - finds best contiguous run of matching words (for entry text)
  // 2. highlightRange ({ start, end }) - highlights words at specific positions (for source text)
  // 3. coveredPositions (Set<number>) - if provided, words NOT in this set are highlighted as gaps
  function renderPaliWithWords(
    text: string,
    matchedWords?: Set<string>,
    highlightRange?: { start: number; end: number },
    coveredPositions?: Set<number> | number[] | object
  ): string {
    // Ensure coveredPositions is a Set (may be array from JSON deserialization, or {} from empty Set)
    let coveredSet: Set<number> | undefined = undefined;
    if (coveredPositions) {
      if (coveredPositions instanceof Set) {
        coveredSet = coveredPositions;
      } else if (Array.isArray(coveredPositions)) {
        coveredSet = new Set(coveredPositions);
      }
      // If it's an object {} (empty Set serialized), leave coveredSet as undefined
    }

    // Normalize multiple spaces to single space first
    const normalizedText = text.replace(/\s+/g, ' ');

    // Word pattern includes Pali letters + all quote types
    const wordPattern = /[a-zA-ZāīūṃṅñṭḍṇḷṁĀĪŪṂṄÑṬḌṆḶṀ'"\u2018\u2019\u201A\u201B\u201C\u201D\u201E\u201F\u2039\u203A«»„‚]+/g;
    const matches = [...normalizedText.matchAll(wordPattern)];

    if (matches.length === 0) return escapeHtml(normalizedText);

    // Determine highlight range
    let highlightStart = -1;
    let highlightEnd = -1;

    // Mode 1: Position-based highlighting (for source text where we know exact positions)
    if (highlightRange && highlightRange.start >= 0 && highlightRange.end >= highlightRange.start) {
      highlightStart = highlightRange.start;
      highlightEnd = Math.min(highlightRange.end, matches.length - 1);
    }
    // Mode 2: Word-based highlighting (for entry text where we match words)
    else if (matchedWords && matchedWords.size > 0) {
      // Build array of which words match
      const wordMatches = matches.map((m, i) => {
        const word = m[0];
        const normalized = normalizePali(word);
        return {
          index: i,
          pos: m.index!,
          length: m[0].length,
          isMatch: normalized ? matchedWords.has(normalized) : false
        };
      });

      // Find the best contiguous run
      let bestRun = { start: -1, end: -1, matchCount: 0, totalWords: 0 };

      for (let start = 0; start < wordMatches.length; start++) {
        if (!wordMatches[start].isMatch) continue;

        let matchCount = 0;
        let lastMatchIdx = start;

        for (let end = start; end < wordMatches.length; end++) {
          if (wordMatches[end].isMatch) {
            matchCount++;
            lastMatchIdx = end;
          }

          const gapFromLastMatch = end - lastMatchIdx;
          if (gapFromLastMatch > 2 && !wordMatches[end].isMatch) {
            break;
          }

          const totalWords = end - start + 1;
          const density = matchCount / totalWords;

          if (matchCount > bestRun.matchCount ||
              (matchCount === bestRun.matchCount && density > bestRun.matchCount / bestRun.totalWords)) {
            bestRun = { start, end: lastMatchIdx, matchCount, totalWords: lastMatchIdx - start + 1 };
          }
        }
      }

      if (bestRun.start !== -1) {
        highlightStart = bestRun.start;
        highlightEnd = bestRun.end;
      }
    }

    // Build HTML with word spans, using wrapper for contiguous highlight
    // Gap words within the highlight get a special class
    let result = '';
    let lastEnd = 0;
    let insideHighlight = false;

    matches.forEach((match, idx) => {
      const word = match[0];
      const pos = match.index!;

      // Check if this word is within the highlight range
      const isInRange = highlightStart !== -1 && idx >= highlightStart && idx <= highlightEnd;

      // Check if this position is covered (matching) or a gap
      const isCovered = !coveredSet || coveredSet.has(idx);
      const isGap = isInRange && !isCovered;

      // Open/close highlight wrapper at range boundaries
      if (isInRange && !insideHighlight) {
        // Add text before highlight starts
        if (pos > lastEnd) {
          const between = normalizedText.substring(lastEnd, pos);
          result += escapeHtml(between);
        }
        result += `<span class="tm-highlight">`;
        insideHighlight = true;
      } else if (!isInRange && insideHighlight) {
        // Close highlight wrapper
        result += `</span>`;
        insideHighlight = false;
        if (pos > lastEnd) {
          const between = normalizedText.substring(lastEnd, pos);
          result += escapeHtml(between);
        }
      } else if (pos > lastEnd) {
        // Normal text between words
        const between = normalizedText.substring(lastEnd, pos);
        result += escapeHtml(between);
      }

      // Clean word for lookup (remove trailing punctuation, quotes)
      const cleanWord = word.replace(/[,;.!?'"'""]+$/g, '').toLowerCase();

      // Build the word span with appropriate highlighting
      let highlightClass = '';
      if (isInRange) {
        highlightClass = isGap ? ' tm-highlight-gap' : ' tm-highlight-word';
      }

      result += `<span class="pali-word${highlightClass}" data-word="${escapeHtml(cleanWord)}" data-original="${escapeHtml(word)}">${escapeHtml(word)}</span>`;

      lastEnd = pos + word.length;
    });

    // Close highlight wrapper if still open
    if (insideHighlight) {
      result += `</span>`;
    }

    // Add any trailing text
    if (lastEnd < normalizedText.length) {
      const trailing = normalizedText.substring(lastEnd);
      if (trailing.trim()) {
        result += escapeHtml(trailing);
      }
    }

    return result;
  }

  // Highlight matched phrase in source text as a contiguous span
  function highlightMatches(text: string, matchedWords: Set<string>): string {
    // Normalize multiple spaces to single space first
    const normalizedText = text.replace(/\s+/g, ' ');

    // Find the BEST contiguous run of matched words (not just first-to-last anywhere)
    // This is important when a word like "bhikkhave" appears multiple times in a paragraph
    // Word pattern includes Pali letters + all quote types (using Unicode escapes for reliability)
    // so "bhikkhavo"ti becomes one token → normalized to bhikkhavoti
    // Quote Unicode: U+2018-201F (curly quotes), U+0027 ('), U+0022 ("), U+2039-203A (angle quotes)
    const wordPattern = /[a-zA-ZāīūṃṅñṭḍṇḷṁĀĪŪṂṄÑṬḌṆḶṀ'"\u2018\u2019\u201A\u201B\u201C\u201D\u201E\u201F\u2039\u203A«»„‚]+/g;
    const matches = [...normalizedText.matchAll(wordPattern)];

    if (matches.length === 0) return escapeHtml(normalizedText);

    // Build array of which words match
    const wordMatches = matches.map((m, i) => {
      const word = m[0];
      const normalized = normalizePali(word);
      return {
        index: i,
        pos: m.index!,
        length: m[0].length,
        isMatch: normalized ? matchedWords.has(normalized) : false
      };
    });

    // Find the best contiguous run: highest count of matched words with minimal gaps
    let bestRun = { start: -1, end: -1, matchCount: 0, totalWords: 0 };

    // Sliding window: find runs where most words are matched
    for (let start = 0; start < wordMatches.length; start++) {
      if (!wordMatches[start].isMatch) continue; // Start from a matched word

      let matchCount = 0;
      let lastMatchIdx = start;

      for (let end = start; end < wordMatches.length; end++) {
        if (wordMatches[end].isMatch) {
          matchCount++;
          lastMatchIdx = end;
        }

        // Allow small gaps (up to 2 non-matching words) within a run
        const gapFromLastMatch = end - lastMatchIdx;
        if (gapFromLastMatch > 2 && !wordMatches[end].isMatch) {
          break; // Too big a gap, end this run
        }

        const totalWords = end - start + 1;
        const density = matchCount / totalWords;

        // Better run if: more matches, or same matches but tighter (higher density)
        if (matchCount > bestRun.matchCount ||
            (matchCount === bestRun.matchCount && density > bestRun.matchCount / bestRun.totalWords)) {
          bestRun = { start, end: lastMatchIdx, matchCount, totalWords: lastMatchIdx - start + 1 };
        }
      }
    }

    if (bestRun.start === -1) return escapeHtml(normalizedText);

    // Get character positions for the best contiguous span
    const startPos = wordMatches[bestRun.start].pos;
    const endWord = wordMatches[bestRun.end];
    const endPos = endWord.pos + endWord.length;

    // Build the highlighted HTML
    const before = normalizedText.substring(0, startPos);
    const highlighted = normalizedText.substring(startPos, endPos);
    const after = normalizedText.substring(endPos);

    return escapeHtml(before) +
           `<strong class="tm-highlight">${escapeHtml(highlighted)}</strong>` +
           escapeHtml(after);
  }

  // Format phrase tab label with discourse count
  function formatPhraseTabLabel(phraseGroup: TMPhraseGroup, sourceWordCount: number, includeCount: boolean = true): string {
    const discCount = phraseGroup.totalCount; // Use true count, not just stored
    const wordLabel = `${phraseGroup.matchedWordCount} words`;

    return includeCount ? `${wordLabel} · ${discCount} match${discCount !== 1 ? 'es' : ''}` : wordLabel;
  }

  // Format discourse reference for display
  function formatDiscourseRef(source: { suttaId: string; paragraphNum: number }): string {
    return `${source.suttaId.toUpperCase()} ¶${source.paragraphNum}`;
  }

  // Get current sutta ID from URL (base ID without paragraph number)
function getCurrentSuttaId(): string {
  const path = window.location.pathname;

  // Extract the discourse ID from the path (e.g., /sn25.1 -> sn25.1, /mn64.1 -> mn64.1)
  const pathMatch = path.match(/\/([a-z]+[\d\.\-]+)/i);
  if (!pathMatch) return '';

  const fullPathId = pathMatch[1].toLowerCase();

  // Check if the full path ID is a valid discourse
  if (routes.includes(fullPathId)) {
    return fullPathId;
  }

  // Check if this might be a paragraph reference (e.g., mn64.1 where mn64 is the discourse)
  const dotIndex = fullPathId.lastIndexOf('.');
  if (dotIndex > 0) {
    const baseId = fullPathId.substring(0, dotIndex);
    if (routes.includes(baseId)) {
      return baseId;
    }
  }

  // Check for range-based discourses (e.g., dhp1 should match dhp1-20)
  // Find any route that contains this ID as part of a range
  const rangeMatch = routes.find(route => {
    const rangePattern = route.match(/^([a-z]+)(\d+)-(\d+)$/i);
    if (rangePattern) {
      const [, prefix, startNum, endNum] = rangePattern;
      const idPattern = fullPathId.match(/^([a-z]+)(\d+)$/i);
      if (idPattern && idPattern[1].toLowerCase() === prefix.toLowerCase()) {
        const num = parseInt(idPattern[2], 10);
        return num >= parseInt(startNum, 10) && num <= parseInt(endNum, 10);
      }
    }
    return false;
  });

  if (rangeMatch) {
    return rangeMatch;
  }

  // Fallback: return the full path ID
  return fullPathId;
}

  // Helper: yield to browser to keep UI responsive during heavy computation
  function yieldToBrowser(): Promise<void> {
    return new Promise(resolve => {
      // Use requestAnimationFrame for smooth yielding
      requestAnimationFrame(() => setTimeout(resolve, 0));
    });
  }

  // Pre-compute TM match counts for all TM buttons
  // Processes in batches with yields to avoid blocking the UI
  async function preComputeTMCounts() {
    // Load the index
    const loaded = await loadTMIndex();
    if (!loaded) return;

    const currentSuttaId = getCurrentSuttaId();

    // Find all TM buttons that don't have pre-computed matches yet
    const buttons = Array.from(document.querySelectorAll('.tm-lookup-btn:not([data-tm-matches])'));

    // Process in batches of 3 to avoid blocking UI
    const BATCH_SIZE = 3;
    let processed = 0;

    for (const btn of buttons) {
      const paliText = btn.getAttribute('data-pali-text');
      if (!paliText) continue;

      // Get paragraph number from parent pali-paragraph's data-pair-id,
      // or from the corresponding english-paragraph which has data-paragraph-number
      const parentPara = btn.closest('.pali-paragraph');
      let paraNum: string | null = null;

      if (parentPara) {
        // Method 1: Use data-pair-id to find corresponding English paragraph
        const pairId = parentPara.getAttribute('data-pair-id');
        if (pairId) {
          const engPara = document.querySelector(`.english-paragraph[data-pair-id="${pairId}"]`);
          paraNum = engPara?.getAttribute('data-paragraph-number') || engPara?.getAttribute('id') || null;
        }
        // Method 2: Fallback - look at previous sibling
        if (!paraNum) {
          const prevSibling = parentPara.previousElementSibling;
          if (prevSibling?.classList.contains('english-paragraph')) {
            paraNum = prevSibling.getAttribute('data-paragraph-number') || prevSibling.getAttribute('id') || null;
          }
        }
      }

      const sourceRef = currentSuttaId && paraNum ? { suttaId: currentSuttaId, paragraphNum: parseInt(paraNum, 10) } : undefined;

      // DEBUG: Log precompute input
      if (paraNum === '13') {
        console.log('[TM Precompute Debug] Para 13 paliText first 100 chars:', paliText.substring(0, 100));
        console.log('[TM Precompute Debug] Para 13 paliText length:', paliText.length);
        // Show first 10 words after normalization
        const debugWords = normalizePali(paliText).split(/\s+/).slice(0, 10);
        console.log('[TM Precompute Debug] Para 13 first 10 words:', debugWords);
      }

      // Compute matches
      const result = findMatches(paliText, paliText, currentSuttaId, sourceRef);

      // DEBUG: Log precompute result
      if (paraNum === '13') {
        console.log('[TM Precompute Debug] Para 13 result phraseGroups:', result?.phraseGroups.length, result?.phraseGroups.map(pg => `${pg.startIndex}-${pg.endIndex}`));
      }

      if (result && result.phraseGroups.length > 0) {
        // Convert Sets to arrays for JSON serialization
        const serializableResult = {
          ...result,
          phraseGroups: result.phraseGroups.map(pg => ({
            ...pg,
            matchedWords: Array.from(pg.matchedWords),
            coveredPositions: pg.coveredPositions ? Array.from(pg.coveredPositions) : undefined,
            discourses: pg.discourses.map(d => ({
              ...d,
              entryCoveredPositions: d.entryCoveredPositions ? Array.from(d.entryCoveredPositions) : undefined,
            })),
          })),
        };

        btn.textContent = `TM (${result.totalDiscourses})`;
        btn.setAttribute('data-tm-matches', JSON.stringify(serializableResult));
      } else {
        // No matches found
        btn.textContent = 'TM (0)';
        (btn as HTMLButtonElement).disabled = true;
        (btn as HTMLElement).style.opacity = '0.5';
      }

      // Yield to browser every BATCH_SIZE paragraphs to keep UI responsive
      processed++;
      if (processed % BATCH_SIZE === 0) {
        await yieldToBrowser();
      }
    }
  }

  // Find "Translation in progress..." spans and add TM buttons to their Pali paragraphs
  // The TM button is placed on the Pali paragraph (right side) for consistent positioning
  // This function just adds buttons - preComputeTMCounts() will fill in the counts
  function enhanceTranslationPlaceholders() {
    // Find all "Translation in progress..." spans
    const placeholders = Array.from(document.querySelectorAll('span.text-gray-400.italic'));

    for (const placeholder of placeholders) {
      if (!placeholder.textContent?.includes('Translation in progress')) continue;

      // The structure is: english-paragraph followed by pali-paragraph (they share data-pair-id)
      // Get the parent paragraph (english-paragraph)
      const englishParagraph = placeholder.closest('p.english-paragraph, p');
      if (!englishParagraph) continue;

      let paliParagraph: Element | null = null;
      let paliText = '';

      // Method 1: Use data-pair-id to find matching pali-paragraph
      const pairId = englishParagraph.getAttribute('data-pair-id');
      if (pairId) {
        paliParagraph = document.querySelector(`p.pali-paragraph[data-pair-id="${pairId}"]`);
        if (paliParagraph) {
          paliText = paliParagraph.textContent || '';
        }
      }

      // Method 2: Look at the next sibling if Method 1 didn't work
      if (!paliText) {
        let nextSibling = englishParagraph.nextElementSibling;
        while (nextSibling) {
          if (nextSibling.classList?.contains('pali-paragraph')) {
            paliParagraph = nextSibling;
            paliText = nextSibling.textContent || '';
            break;
          }
          // Also check if it's a plain p tag with Pali diacritics
          if (nextSibling.tagName === 'P' && /[āīūṃṅñṭḍṇḷṁ]/i.test(nextSibling.textContent || '')) {
            paliParagraph = nextSibling;
            paliText = nextSibling.textContent || '';
            break;
          }
          nextSibling = nextSibling.nextElementSibling;
        }
      }

      if (!paliText || paliText.length < 20 || !paliParagraph) continue;

      // Skip if Pali paragraph already has a TM button
      if (paliParagraph.querySelector('.tm-lookup-btn')) continue;

      // Add TM button to the Pali paragraph (right side, consistent with other paragraphs)
      const btn = document.createElement('button');
      btn.className = 'tm-lookup-btn';
      btn.textContent = 'TM';
      btn.title = 'Translation Memory: Click to find similar translations';
      btn.setAttribute('data-pali-text', paliText);

      // Position at the right side of the Pali paragraph
      const para = paliParagraph as HTMLElement;
      para.style.position = 'relative';
      btn.style.position = 'absolute';
      btn.style.right = '0';
      btn.style.top = '0';
      para.appendChild(btn);
    }
  }

  // Track the element that opened the popover for focus restoration
  let popoverTriggerElement: HTMLElement | null = null;

  // Show popover with match details
  // activePhraseIdx: which phrase group is selected (Row 1)
  // activeDiscourseIdx: which discourse within that phrase is selected (Row 2)
  // focusRow: which row to focus after render ('phrase' | 'discourse' | 'auto')
  // triggerElement: the element that opened the popover (for focus restoration on close)
  function showPopover(result: TMMatchResult, activePhraseIdx: number = 0, activeDiscourseIdx: number = 0, focusRow: 'phrase' | 'discourse' | 'auto' = 'auto', triggerElement?: HTMLElement) {
    // DEBUG: Log what showPopover receives
    console.log('[TM UI Debug] showPopover called with:', {
      phraseGroupCount: result.phraseGroups.length,
      phraseGroups: result.phraseGroups.map((pg, i) => ({
        index: i,
        wordRange: `${pg.startIndex}-${pg.endIndex}`,
        matchedWordCount: pg.matchedWordCount,
        segment: pg.matchedSegment.substring(0, 50) + '...'
      }))
    });

    // Store trigger element for focus restoration (only on initial open)
    if (triggerElement) {
      popoverTriggerElement = triggerElement;
    }

    // Remove any existing popover
    const existing = document.querySelector('.tm-popover-overlay');
    if (existing) existing.remove();

    const phraseGroup = result.phraseGroups[activePhraseIdx];
    // Use diverse discourses for display, fallback to regular discourses
    const displayDiscourses = phraseGroup.diverseDiscourses || phraseGroup.discourses.slice(0, 3);
    const discourse = displayDiscourses[activeDiscourseIdx] || displayDiscourses[0];
    const percentage = Math.round(phraseGroup.similarity * 100);
    const sourceUrl = `/${discourse.suttaId}.${discourse.paragraphNum}?pli=true`;
    const isPartialMatch = percentage < 95;

    // Row 1: Phrase pattern tabs - only show if more than one phrase group
    const showPhraseRow = result.phraseGroups.length > 1;
    console.log('[TM UI Debug] Building tabs:', { showPhraseRow, groupCount: result.phraseGroups.length });
    const phraseTabsHtml = showPhraseRow ? `
      <div class="tm-tabs tm-phrase-tabs">
        ${result.phraseGroups.map((pg, i) => {
          console.log(`[TM UI Debug] Rendering tab ${i}:`, { wordCount: pg.matchedWordCount, range: `${pg.startIndex}-${pg.endIndex}` });
          const isActive = i === activePhraseIdx;
          const label = formatPhraseTabLabel(pg, result.sourceWordCount);
          return `<button class="tm-tab tm-phrase-tab ${isActive ? 'tm-tab-active' : ''}" data-phrase-index="${i}">
            ${label}
          </button>`;
        }).join('')}
      </div>
    ` : '';

    // Row 2: Discourse tabs for the selected phrase (show top 3 diverse discourses)
    // Use totalCount for the actual count, not just stored discourses
    const totalInGroup = phraseGroup.totalCount;
    const remainingDiscourses = totalInGroup - displayDiscourses.length;

    let discourseTabsHtml = `
      <div class="tm-tabs tm-discourse-tabs">
        ${displayDiscourses.map((d, i) => {
          const isActive = i === activeDiscourseIdx;
          const discRef = formatDiscourseRef({ suttaId: d.suttaId, paragraphNum: d.paragraphNum });
          return `<button class="tm-tab tm-discourse-tab ${isActive ? 'tm-tab-active' : ''}" data-discourse-index="${i}">
            ${discRef}
          </button>`;
        }).join('')}
        ${remainingDiscourses > 0 ? `<span class="tm-more-count">+${remainingDiscourses} match${remainingDiscourses !== 1 ? 'es' : ''}</span>` : ''}
      </div>
    `;

    // Render source Pali with clickable word spans and position-based highlighting
    // Use startIndex/endIndex for accurate highlighting of the matched range
    // Pass coveredPositions to show gap words with different styling
    const sourceHighlightRange = (phraseGroup.startIndex !== undefined && phraseGroup.endIndex !== undefined)
      ? { start: phraseGroup.startIndex, end: phraseGroup.endIndex }
      : undefined;
    const renderedSourcePali = renderPaliWithWords(result.sourcePali, undefined, sourceHighlightRange, phraseGroup.coveredPositions);

    // Format source reference link (e.g., "MN112 ¶25 ↗")
    const sourceRefLink = result.sourceRef
      ? `<a href="/${result.sourceRef.suttaId}.${result.sourceRef.paragraphNum}?pli=true" target="_blank" class="tm-discourse-link" title="Open ${formatDiscourseRef(result.sourceRef)} in new tab">${formatDiscourseRef(result.sourceRef)} ↗</a>`
      : '';

    // Always show source paragraph with highlighting
    const sourcePaliSection = `
          <div class="tm-section">
            <div class="tm-section-label">
              Source Paragraph (to translate)
              ${sourceRefLink}
            </div>
            <div class="tm-section-content tm-pali tm-source-pali pali-paragraph">${renderedSourcePali}</div>
          </div>
    `;

    // Build title - include phrase label (without count) if only one phrase group
    const singlePhraseLabel = !showPhraseRow ? ` · ${formatPhraseTabLabel(phraseGroup, result.sourceWordCount, false)}` : '';

    // Create popover
    const overlay = document.createElement('div');
    overlay.className = 'tm-popover-overlay';

    // Render English with glosses as tooltips
    const renderedEnglish = renderGlosses(discourse.englishOriginal);

    // Render matched Pali phrase with position-based highlighting
    // Use entryStartIndex/entryEndIndex to highlight the exact matching range in the entry text
    // Pass entryCoveredPositions to show gap words with different styling
    const entryHighlightRange = (discourse.entryStartIndex !== undefined && discourse.entryEndIndex !== undefined)
      ? { start: discourse.entryStartIndex, end: discourse.entryEndIndex }
      : undefined;
    const renderedMatchedPali = renderPaliWithWords(discourse.paliOriginal, undefined, entryHighlightRange, discourse.entryCoveredPositions);

    overlay.innerHTML = `
      <div class="tm-popover" role="dialog" aria-modal="true">
        <div class="tm-popover-header">
          <span class="tm-popover-title">
            Translation Memory <span class="tm-discourse-count">(${result.totalDiscourses} text match${result.totalDiscourses !== 1 ? 'es' : ''})${singlePhraseLabel}</span>
          </span>
          <button class="tm-popover-close" aria-label="Close">&times;</button>
        </div>
        ${phraseTabsHtml}
        ${discourseTabsHtml}
        <div class="tm-popover-content">
          ${sourcePaliSection}
          <div class="tm-section">
            <div class="tm-section-label">
              Matched Phrase (Pali)
              <a href="${sourceUrl}" target="_blank" class="tm-discourse-link" title="Open ${formatDiscourseRef({ suttaId: discourse.suttaId, paragraphNum: discourse.paragraphNum })} in new tab">
                ${formatDiscourseRef({ suttaId: discourse.suttaId, paragraphNum: discourse.paragraphNum })} ↗
              </a>
            </div>
            <div class="tm-section-content tm-pali tm-matched-phrase pali-paragraph">${renderedMatchedPali}</div>
          </div>
          <div class="tm-section">
            <div class="tm-section-label">Matched Translation</div>
            <div class="tm-section-content tm-english tm-selectable" data-raw-english="${escapeHtml(discourse.englishOriginal)}">${renderedEnglish}</div>
          </div>
        </div>
      </div>
    `;

    document.body.appendChild(overlay);

    // Selection-based copy tooltip for English text
    const selectableEl = overlay.querySelector('.tm-selectable') as HTMLElement;
    let copyTooltip: HTMLElement | null = null;

    function removeCopyTooltip() {
      if (copyTooltip) {
        copyTooltip.remove();
        copyTooltip = null;
      }
    }

    function getRawTextForSelection(selection: Selection, rawEnglish: string): string {
      // Get the selected text and find corresponding raw text
      const selectedText = selection.toString();
      if (!selectedText) return '';

      const fullText = selectableEl?.textContent || '';

      // If full selection, return complete raw English
      if (selectedText.trim() === fullText.trim()) {
        return rawEnglish;
      }

      // Partial selection: try to map back to raw text with gloss syntax
      // Find where the selection starts/ends in the visible text
      const selStart = fullText.indexOf(selectedText);
      if (selStart === -1) {
        // Selection spans multiple nodes or has whitespace differences - return as-is
        return selectedText;
      }
      const selEnd = selStart + selectedText.length;

      // Build a mapping from visible text positions to raw text positions
      // Raw format: text |term::definition [pali]| more text
      // Visible: text term more text
      let visiblePos = 0;
      let rawPos = 0;
      let rawStart = 0;
      let rawEnd = rawEnglish.length;

      const glossPattern = /\|([^|:]+)::([^|]+)\|/g;
      let lastEnd = 0;
      let match;

      // Build segments: [{visible, rawStart, rawEnd}]
      const segments: Array<{visibleStart: number, visibleEnd: number, rawStart: number, rawEnd: number}> = [];

      while ((match = glossPattern.exec(rawEnglish)) !== null) {
        // Text before this gloss
        const beforeText = rawEnglish.substring(lastEnd, match.index);
        if (beforeText.length > 0) {
          segments.push({
            visibleStart: visiblePos,
            visibleEnd: visiblePos + beforeText.length,
            rawStart: lastEnd,
            rawEnd: match.index
          });
          visiblePos += beforeText.length;
        }

        // The gloss itself: |term::definition| -> term
        const term = match[1];
        segments.push({
          visibleStart: visiblePos,
          visibleEnd: visiblePos + term.length,
          rawStart: match.index,
          rawEnd: match.index + match[0].length
        });
        visiblePos += term.length;
        lastEnd = match.index + match[0].length;
      }

      // Text after last gloss
      if (lastEnd < rawEnglish.length) {
        const afterText = rawEnglish.substring(lastEnd);
        segments.push({
          visibleStart: visiblePos,
          visibleEnd: visiblePos + afterText.length,
          rawStart: lastEnd,
          rawEnd: rawEnglish.length
        });
      }

      // Find raw positions for selection
      for (const seg of segments) {
        if (seg.visibleStart <= selStart && selStart < seg.visibleEnd) {
          // Selection starts in this segment
          const offset = selStart - seg.visibleStart;
          rawStart = seg.rawStart + offset;
          // If it's a gloss segment, include the whole gloss
          if (rawEnglish[seg.rawStart] === '|') {
            rawStart = seg.rawStart;
          }
        }
        if (seg.visibleStart < selEnd && selEnd <= seg.visibleEnd) {
          // Selection ends in this segment
          const offset = selEnd - seg.visibleStart;
          rawEnd = seg.rawStart + offset;
          // If it's a gloss segment, include the whole gloss
          if (rawEnglish[seg.rawStart] === '|') {
            rawEnd = seg.rawEnd;
          }
        }
      }

      return rawEnglish.substring(rawStart, rawEnd);
    }

    selectableEl?.addEventListener('mouseup', (e) => {
      const selection = window.getSelection();
      if (!selection || selection.isCollapsed || !selection.toString().trim()) {
        removeCopyTooltip();
        return;
      }

      // Check if selection is within the selectable element
      const range = selection.getRangeAt(0);
      if (!selectableEl.contains(range.commonAncestorContainer)) {
        removeCopyTooltip();
        return;
      }

      // Create copy tooltip near the selection
      removeCopyTooltip();
      const rect = range.getBoundingClientRect();

      copyTooltip = document.createElement('div');
      copyTooltip.className = 'tm-selection-copy-tooltip';
      copyTooltip.innerHTML = '<button class="tm-selection-copy-btn">📋 Copy raw</button>';
      copyTooltip.style.position = 'fixed';
      copyTooltip.style.left = `${rect.left + rect.width / 2}px`;
      copyTooltip.style.top = `${rect.top - 35}px`;
      copyTooltip.style.transform = 'translateX(-50%)';
      copyTooltip.style.zIndex = '10001';

      document.body.appendChild(copyTooltip);

      copyTooltip.querySelector('.tm-selection-copy-btn')?.addEventListener('click', async (ev) => {
        ev.stopPropagation();
        const rawEnglish = discourse.englishOriginal;
        const rawText = getRawTextForSelection(selection, rawEnglish);

        try {
          await navigator.clipboard.writeText(rawText);
          const btn = copyTooltip?.querySelector('.tm-selection-copy-btn');
          if (btn) {
            btn.textContent = '✓ Copied!';
            btn.classList.add('copied');
            setTimeout(removeCopyTooltip, 1000);
          }
        } catch (err) {
          console.error('Failed to copy:', err);
        }
      });
    });

    // Remove tooltip when clicking elsewhere
    overlay.addEventListener('mousedown', (e) => {
      if (copyTooltip && !copyTooltip.contains(e.target as Node)) {
        removeCopyTooltip();
      }
    });

    // Gloss click handlers - BottomDrawer listens on document for .tooltip-text clicks
    // We just need to NOT stop propagation so clicks bubble up to BottomDrawer's handler
    overlay.querySelectorAll('.tm-gloss').forEach(gloss => {
      gloss.addEventListener('click', (e) => {
        // Don't stop propagation - let it bubble to BottomDrawer's document click handler
        // The .tooltip-text class is enough for BottomDrawer to handle it
        e.preventDefault(); // Prevent any default behavior
        // Note: If clicking gloss doesn't work, may need to close popover first
      });
    });

    // Phrase tab click handlers (Row 1)
    overlay.querySelectorAll('.tm-phrase-tab').forEach(tab => {
      tab.addEventListener('click', (e) => {
        const phraseIdx = parseInt((e.target as HTMLElement).getAttribute('data-phrase-index') || '0');
        showPopover(result, phraseIdx, 0, 'phrase'); // Stay on phrase row
      });
    });

    // Discourse tab click handlers (Row 2)
    overlay.querySelectorAll('.tm-discourse-tab').forEach(tab => {
      tab.addEventListener('click', (e) => {
        const discourseIdx = parseInt((e.target as HTMLElement).getAttribute('data-discourse-index') || '0');
        showPopover(result, activePhraseIdx, discourseIdx, 'discourse'); // Stay on discourse row
      });
    });

    // Close popover base function
    const closePopover = () => {
      removeCopyTooltip();
      overlay.remove();
      // Restore focus to the element that opened the popover
      if (popoverTriggerElement) {
        popoverTriggerElement.focus();
        popoverTriggerElement = null;
      }
    };

    // Listen for selection changes to hide copy tooltip when text is unselected
    const selectionChangeHandler = () => {
      const selection = window.getSelection();
      if (!selection || selection.isCollapsed || !selection.toString().trim()) {
        removeCopyTooltip();
      }
    };
    document.addEventListener('selectionchange', selectionChangeHandler);

    // Prevent page scroll when popover is open, but allow scroll inside popover content
    const preventBackgroundScroll = (e: WheelEvent | TouchEvent) => {
      const popoverContent = overlay.querySelector('.tm-popover-content') as HTMLElement;
      if (!popoverContent) {
        e.preventDefault();
        return;
      }

      // Check if content is scrollable
      const isScrollable = popoverContent.scrollHeight > popoverContent.clientHeight;
      if (!isScrollable) {
        e.preventDefault();
        return;
      }

      // Check if the event target is inside the scrollable content
      const target = e.target as HTMLElement;
      if (!popoverContent.contains(target)) {
        e.preventDefault();
        return;
      }

      // For wheel events, prevent scroll at boundaries to avoid background scroll
      if (e instanceof WheelEvent) {
        const { scrollTop, scrollHeight, clientHeight } = popoverContent;
        const atTop = scrollTop <= 0;
        const atBottom = scrollTop + clientHeight >= scrollHeight;

        // Scrolling up at top or down at bottom would scroll background
        if ((e.deltaY < 0 && atTop) || (e.deltaY > 0 && atBottom)) {
          e.preventDefault();
          return;
        }
      }

      // Allow the scroll inside popover content
      e.stopPropagation();
    };
    overlay.addEventListener('wheel', preventBackgroundScroll, { passive: false });
    overlay.addEventListener('touchmove', preventBackgroundScroll, { passive: false });

    // Cleanup function for all listeners
    let handleKeydown: ((e: KeyboardEvent) => void) | null = null;

    const cleanupAndClose = () => {
      overlay.removeEventListener('wheel', preventBackgroundScroll);
      overlay.removeEventListener('touchmove', preventBackgroundScroll);
      if (handleKeydown) {
        document.removeEventListener('keydown', handleKeydown);
      }
      document.removeEventListener('selectionchange', selectionChangeHandler);
      closePopover();
    };

    // Close button and overlay click handlers
    overlay.querySelector('.tm-popover-close')?.addEventListener('click', cleanupAndClose);
    overlay.addEventListener('click', (e) => {
      if (e.target === overlay) cleanupAndClose();
    });

    // Escape key handler
    handleKeydown = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        cleanupAndClose();
        return;
      }

      // Arrow key navigation for tabs
      const activeElement = document.activeElement as HTMLElement;
      const isInPhraseRow = activeElement?.classList.contains('tm-phrase-tab');
      const isInDiscourseRow = activeElement?.classList.contains('tm-discourse-tab');

      // Prevent page scroll on arrow keys ONLY when focus is on tabs
      // This allows arrow key scrolling inside the popover content when not focused on tabs
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
        if (isInPhraseRow || isInDiscourseRow) {
          e.preventDefault();
        } else {
          // Not on tabs - check if we should allow default scroll behavior
          const popoverContent = overlay.querySelector('.tm-popover-content') as HTMLElement;
          if (popoverContent && popoverContent.contains(activeElement)) {
            // Allow arrow key scrolling inside popover content
            return;
          }
          // Prevent background page scroll
          e.preventDefault();
        }
      }

      if (!isInPhraseRow && !isInDiscourseRow) return;

      const currentRow = isInPhraseRow ? 'phrase' : 'discourse';
      const tabs = currentRow === 'phrase'
        ? Array.from(overlay.querySelectorAll('.tm-phrase-tab')) as HTMLElement[]
        : Array.from(overlay.querySelectorAll('.tm-discourse-tab')) as HTMLElement[];

      const currentIdx = tabs.indexOf(activeElement);

      if (e.key === 'ArrowLeft' && currentIdx > 0) {
        e.preventDefault();
        tabs[currentIdx - 1].focus();
      } else if (e.key === 'ArrowRight' && currentIdx < tabs.length - 1) {
        e.preventDefault();
        tabs[currentIdx + 1].focus();
      } else if (e.key === 'ArrowUp' && isInDiscourseRow && showPhraseRow) {
        // Move from discourse row to phrase row - maintain column position
        e.preventDefault();
        const phraseTabs = Array.from(overlay.querySelectorAll('.tm-phrase-tab')) as HTMLElement[];
        if (phraseTabs.length > 0) {
          // Focus tab at same column index, or last tab if current row has more tabs
          const targetIdx = Math.min(currentIdx, phraseTabs.length - 1);
          phraseTabs[targetIdx].focus();
        }
      } else if (e.key === 'ArrowDown' && isInPhraseRow) {
        // Move from phrase row to discourse row - maintain column position
        e.preventDefault();
        const discourseTabs = Array.from(overlay.querySelectorAll('.tm-discourse-tab')) as HTMLElement[];
        if (discourseTabs.length > 0) {
          // Focus tab at same column index, or last tab if current row has more tabs
          const targetIdx = Math.min(currentIdx, discourseTabs.length - 1);
          discourseTabs[targetIdx].focus();
        }
      } else if (e.key === 'Enter' || e.key === ' ') {
        // Activate the focused tab
        e.preventDefault();
        activeElement.click();
      }
    };
    document.addEventListener('keydown', handleKeydown);

    // Auto-focus: respect focusRow parameter, default to first available row
    setTimeout(() => {
      const shouldFocusPhrase = focusRow === 'phrase' || (focusRow === 'auto' && showPhraseRow);
      const shouldFocusDiscourse = focusRow === 'discourse' || (focusRow === 'auto' && !showPhraseRow);

      if (shouldFocusPhrase && showPhraseRow) {
        const activeTab = overlay.querySelector('.tm-phrase-tab.tm-tab-active') as HTMLElement;
        activeTab?.focus();
      } else if (shouldFocusDiscourse) {
        const activeTab = overlay.querySelector('.tm-discourse-tab.tm-tab-active') as HTMLElement;
        activeTab?.focus();
      }
    }, 50);

    // Clean up selection listener when popover is removed
    const observer = new MutationObserver((mutations) => {
      for (const mutation of mutations) {
        for (const node of mutation.removedNodes) {
          if (node === overlay) {
            document.removeEventListener('selectionchange', selectionChangeHandler);
            observer.disconnect();
          }
        }
      }
    });
    observer.observe(document.body, { childList: true });
  }

  function escapeHtml(text: string): string {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  // Render glosses in English text: |term::definition [paliterm]| → clickable tooltip
  function renderGlosses(text: string): string {
    // First escape HTML, then replace gloss patterns
    const escaped = escapeHtml(text);

    // Pattern: |term::definition [paliterm]| or |term::definition|
    return escaped.replace(
      /\|([^|:]+)::([^|]+)\|/g,
      (_, term, definition) => {
        const escapedDef = definition.replace(/"/g, '&quot;');
        return `<span class="tooltip-text tm-gloss" data-tooltip-content="${escapedDef}">${term}</span>`;
      }
    );
  }

  // Get raw English text (with gloss syntax preserved) for copying
  function getRawEnglish(text: string): string {
    return text; // Already raw, no transformation needed
  }

  // Add TM lookup button to all Pali paragraphs (lazy loading - compute on click)
  function addTMLookupButtons() {
    // Find all Pali paragraphs
    const paliParagraphs = document.querySelectorAll('p.pali-paragraph');

    for (const paliPara of paliParagraphs) {
      // Skip if already has a TM button
      if (paliPara.querySelector('.tm-lookup-btn')) continue;

      // Normalize whitespace: collapse multiple spaces/nbsp to single space
      const paliText = (paliPara.textContent || '').replace(/\s+/g, ' ').trim();
      if (paliText.length < 20) continue;

      // Create a TM lookup button (no pre-computation)
      const btn = document.createElement('button');
      btn.className = 'tm-lookup-btn';
      btn.textContent = 'TM';
      btn.title = 'Translation Memory: Click to find similar translations';

      // Store the pali text for lazy loading
      btn.setAttribute('data-pali-text', paliText);

      // Position at the end of the paragraph
      const para = paliPara as HTMLElement;
      para.style.position = 'relative';
      btn.style.position = 'absolute';
      btn.style.right = '0';
      btn.style.top = '0';
      para.appendChild(btn);
    }
  }

  // Load TM index on demand
  // In dev mode, always fetch fresh to pick up changes from contentWatcher
  async function loadTMIndex(): Promise<boolean> {
    // In dev mode, always reload to pick up live updates
    const isDev = import.meta.env?.DEV || window.location.hostname === 'localhost';
    if (tmIndex && !isDev) return true;

    try {
      // Add cache-busting query param in dev mode
      const cacheBuster = isDev ? `?t=${Date.now()}` : '';
      const response = await fetch(`/src/data/translationMemory.json${cacheBuster}`);
      if (response.ok) {
        tmIndex = await response.json();
        return true;
      }
    } catch {
      // Translation Memory index not available - this is expected when TM index doesn't exist
    }
    return false;
  }

  // Click handler for TM lookup buttons (lazy loading)
  document.addEventListener('click', async (e) => {
    const trigger = (e.target as HTMLElement).closest('.tm-match-trigger, .tm-lookup-btn');
    if (!trigger) return;

    e.preventDefault();

    // Check for pre-computed matches first
    const matchDataStr = trigger.getAttribute('data-tm-matches');
    console.log('[TM UI Debug] Click handler - has cached data:', !!matchDataStr);
    if (matchDataStr) {
      try {
        const result: TMMatchResult = JSON.parse(matchDataStr);
        console.log('[TM UI Debug] Using CACHED data, phraseGroups:', result.phraseGroups.length);
        // Restore Set objects that were serialized as arrays
        result.phraseGroups.forEach(pg => {
          pg.matchedWords = new Set(pg.matchedWords as unknown as string[]);
          if (pg.coveredPositions) {
            pg.coveredPositions = new Set(pg.coveredPositions as unknown as number[]);
          }
          pg.discourses.forEach(d => {
            if (d.entryCoveredPositions) {
              d.entryCoveredPositions = new Set(d.entryCoveredPositions as unknown as number[]);
            }
          });
        });
        showPopover(result, 0, 0, 'auto', trigger as HTMLElement);
        return;
      } catch (err) {
        console.error('Failed to parse TM match data:', err);
      }
    }

    // Lazy load: get pali text and compute matches on demand
    const paliText = trigger.getAttribute('data-pali-text');
    if (!paliText) return;

    // Show loading state
    const originalText = trigger.textContent;
    trigger.textContent = 'Loading...';
    (trigger as HTMLButtonElement).disabled = true;

    // Load index if needed
    const loaded = await loadTMIndex();
    if (!loaded) {
      trigger.textContent = 'TM (unavailable)';
      return;
    }

    const currentSuttaId = getCurrentSuttaId();

    // Get paragraph number from parent pali-paragraph's data-pair-id,
    // or from the corresponding english-paragraph which has data-paragraph-number
    const parentPara = trigger.closest('.pali-paragraph');
    let paraNum: string | null = null;

    if (parentPara) {
      // Method 1: Use data-pair-id to find corresponding English paragraph
      const pairId = parentPara.getAttribute('data-pair-id');
      if (pairId) {
        const engPara = document.querySelector(`.english-paragraph[data-pair-id="${pairId}"]`);
        paraNum = engPara?.getAttribute('data-paragraph-number') || engPara?.getAttribute('id') || null;
      }
      // Method 2: Fallback - look at previous sibling
      if (!paraNum) {
        const prevSibling = parentPara.previousElementSibling;
        if (prevSibling?.classList.contains('english-paragraph')) {
          paraNum = prevSibling.getAttribute('data-paragraph-number') || prevSibling.getAttribute('id') || null;
        }
      }
    }

    const sourceRef = currentSuttaId && paraNum ? { suttaId: currentSuttaId, paragraphNum: parseInt(paraNum, 10) } : undefined;

    const result = findMatches(paliText, paliText, currentSuttaId, sourceRef);
    console.log('[TM UI Debug] FRESH computation, phraseGroups:', result?.phraseGroups.length);

    if (result && result.phraseGroups.length > 0) {
      // Update button with count
      trigger.textContent = `TM (${result.totalDiscourses})`;
      (trigger as HTMLButtonElement).disabled = false;

      // Cache the result for future clicks
      const serializableResult = {
        ...result,
        phraseGroups: result.phraseGroups.map(pg => ({
          ...pg,
          matchedWords: Array.from(pg.matchedWords),
          coveredPositions: pg.coveredPositions ? Array.from(pg.coveredPositions) : undefined,
          discourses: pg.discourses.map(d => ({
            ...d,
            entryCoveredPositions: d.entryCoveredPositions ? Array.from(d.entryCoveredPositions) : undefined,
          })),
        })),
      };
      trigger.setAttribute('data-tm-matches', JSON.stringify(serializableResult));
      trigger.removeAttribute('data-pali-text'); // No longer needed

      showPopover(result, 0, 0, 'auto', trigger as HTMLElement);
    } else {
      trigger.textContent = 'TM (0)';
      (trigger as HTMLButtonElement).disabled = false;
    }
  });

  // Initialize when DOM is ready
  async function initialize() {
    // First, immediately add placeholder TM buttons to all Pali paragraphs (fast, no computation)
    addTMLookupButtons();

    // Then, pre-compute TM for "Translation in progress..." paragraphs in background
    // Use requestIdleCallback to avoid blocking the main thread
    scheduleBackgroundComputation();
  }

  // Schedule non-blocking background computation for TM match counts
  function scheduleBackgroundComputation() {
    // Use requestIdleCallback if available, otherwise setTimeout
    const scheduleIdle = (window as any).requestIdleCallback ||
      ((fn: () => void) => setTimeout(fn, 100));

    scheduleIdle(async () => {
      // First add any missing buttons for translation-in-progress paragraphs
      enhanceTranslationPlaceholders();
      // Then compute match counts for all buttons (non-blocking with batching)
      await preComputeTMCounts();
    });
  }

  // Expose debug functions globally for console debugging and testing
  (window as any).tmDebug = {
    // Run matching on any Pali text
    findMatches: (paliText: string, suttaId?: string) => {
      if (!tmIndex) {
        console.warn('[TM Debug] Index not loaded. Call loadIndex() first.');
        return null;
      }
      const result = findMatches(paliText, paliText, suttaId);
      console.log('[TM Debug] Match result:', result);
      return result;
    },

    // Load the index (call this first)
    loadIndex: async () => {
      const loaded = await loadTMIndex();
      if (loaded) {
        console.log('[TM Debug] Index loaded:', {
          entries: tmIndex?.entries.length,
          ngrams: Object.keys(tmIndex?.ngrams || {}).length,
          ngramSize: tmIndex?.ngramSize,
        });
      }
      return loaded;
    },

    // Enable/disable verbose debug logging
    setVerbose: (enabled: boolean) => {
      (window as any).tmDebugVerbose = enabled;
      console.log(`[TM Debug] Verbose logging ${enabled ? 'enabled' : 'disabled'}`);
    },

    // Get index stats
    getIndexStats: () => {
      if (!tmIndex) return null;
      return {
        entries: tmIndex.entries.length,
        ngrams: Object.keys(tmIndex.ngrams || {}).length,
        ngramSize: tmIndex.ngramSize,
        version: tmIndex.version,
      };
    },

    // Normalize Pali text (for debugging)
    normalize: normalizePali,

    // Check if a word is a stop word
    isStopWord: isStopWord,

    // Get words from text
    getWords: (text: string) => {
      const normalized = normalizePali(text);
      const words = normalized.split(/\s+/).filter(w => w.length > 0);
      const contentWords = words.filter(w => !isStopWord(w));
      const result = {
        all: words,
        content: contentWords,
        totalCount: words.length,
        contentCount: contentWords.length,
      };
      console.log(JSON.stringify(result, null, 2));
      return result;
    },

    // Debug n-gram matching: show raw candidates before processing
    findNgramCandidates: (paliText: string) => {
      if (!tmIndex) {
        console.warn('[TM Debug] Index not loaded. Call loadIndex() first.');
        return null;
      }
      const normalized = normalizePali(paliText);
      const words = normalized.split(/\s+/).filter(w => w.length > 0);
      const ngramSize = tmIndex.ngramSize || 5;
      const queryNgrams = extractNgrams(words, ngramSize);

      console.log(`[TM Debug] Query has ${words.length} words, ${queryNgrams.length} n-grams`);
      console.log('[TM Debug] First 5 n-grams:', queryNgrams.slice(0, 5));

      // Find which n-grams have matches
      const matchedNgrams: Array<{ ngram: string; entryCount: number }> = [];
      for (const ngram of queryNgrams) {
        const entryIds = tmIndex.ngrams?.[ngram];
        if (entryIds) {
          matchedNgrams.push({ ngram, entryCount: entryIds.length });
        }
      }

      console.log(`[TM Debug] ${matchedNgrams.length}/${queryNgrams.length} n-grams have matches`);
      console.log('[TM Debug] Matched n-grams:', matchedNgrams);

      // Count total unique entries
      const allEntryIds = new Set<number>();
      for (const ngram of queryNgrams) {
        const entryIds = tmIndex.ngrams?.[ngram];
        if (entryIds) {
          entryIds.forEach(id => allEntryIds.add(id));
        }
      }
      console.log(`[TM Debug] Total unique candidate entries: ${allEntryIds.size}`);

      return {
        words: words.length,
        ngrams: queryNgrams.length,
        matchedNgrams: matchedNgrams.length,
        candidateEntries: allEntryIds.size,
        matchedNgramDetails: matchedNgrams,
      };
    },

    // Find matches and return JSON-stringified result for easy copy/paste
    // Pass paragraphNum to properly filter out self-matching
    findMatchesJSON: (paliText: string, suttaId?: string, paragraphNum?: number) => {
      if (!tmIndex) {
        console.warn('[TM Debug] Index not loaded. Call loadIndex() first.');
        return null;
      }
      // Create sourceRef if both suttaId and paragraphNum provided (to skip self-matching)
      const sourceRef = suttaId && paragraphNum ? { suttaId, paragraphNum } : undefined;
      const result = findMatches(paliText, paliText, suttaId, sourceRef);
      if (result) {
        // Convert Sets to arrays for JSON serialization
        const serializable = {
          ...result,
          phraseGroups: result.phraseGroups.map(pg => ({
            ...pg,
            matchedWords: [...pg.matchedWords],
            discourses: pg.discourses.map(d => ({
              suttaId: d.suttaId,
              paragraphNum: d.paragraphNum,
              collection: d.collection,
              contentWordCount: d.contentWordCount, // Include for debugging
            })),
            diverseDiscourses: pg.diverseDiscourses.map(d => ({
              suttaId: d.suttaId,
              paragraphNum: d.paragraphNum,
              collection: d.collection,
              contentWordCount: d.contentWordCount, // Include for debugging
            })),
          })),
        };
        console.log(JSON.stringify(serializable, null, 2));
        return serializable;
      }
      return null;
    },

    // Get Pali paragraphs from a discourse element on the page
    // Usage: tmDebug.getPaliParagraphs() - gets all paragraphs from current page
    getPaliParagraphs: () => {
      // Look for actual content paragraphs, not the title
      // Only select .pali-paragraph elements (the actual paragraphs)
      // Avoid [lang="pi"] alone since it might match containers
      const paliParas = document.querySelectorAll('.pali-paragraph');
      const seen = new Set<string>();
      const paragraphs: Array<{ num: number; text: string }> = [];
      let fallbackNum = 0;
      paliParas.forEach((el) => {
        // Normalize whitespace same as precompute
        const text = (el.textContent || '').replace(/\s+/g, ' ').trim();
        // Skip very short elements that are likely titles (less than 30 chars and no periods)
        if (text && (text.length > 30 || text.includes('.'))) {
          // Deduplicate by text content
          if (seen.has(text)) return;
          seen.add(text);

          // Get actual paragraph number from data-paragraph-number attribute
          // Or find via data-pair-id from the corresponding English paragraph
          let paraNum: number | null = null;
          const attrNum = el.getAttribute('data-paragraph-number');
          if (attrNum) {
            paraNum = parseInt(attrNum, 10);
          } else {
            // Try to find via pair-id
            const pairId = el.getAttribute('data-pair-id');
            if (pairId) {
              const englishPara = document.querySelector(`.english-paragraph[data-pair-id="${pairId}"]`);
              const engNum = englishPara?.getAttribute('data-paragraph-number');
              if (engNum) {
                paraNum = parseInt(engNum, 10);
              }
            }
          }

          // Fallback to sequential numbering if no attribute found
          if (paraNum === null || isNaN(paraNum)) {
            fallbackNum++;
            paraNum = fallbackNum;
          }

          paragraphs.push({ num: paraNum, text });
        }
      });
      console.log(`Found ${paragraphs.length} Pali paragraphs`);
      return paragraphs;
    },

    // Find matches for specific paragraphs on current page
    // Usage: tmDebug.findPageMatches() - all paragraphs
    // Usage: tmDebug.findPageMatches(3) - just paragraph 3
    // Usage: tmDebug.findPageMatches(1, 5) - paragraphs 1 through 5
    findPageMatches: async (startPara?: number, endPara?: number) => {
      const loaded = await loadTMIndex();
      if (!loaded) {
        console.warn('[TM Debug] Failed to load index');
        return null;
      }

      const currentSuttaId = getCurrentSuttaId();
      const paragraphs = (window as any).tmDebug.getPaliParagraphs();

      // Filter paragraphs by actual paragraph number (not array index)
      // If startPara provided, find paragraphs with that number or in range
      let filteredParagraphs = paragraphs;
      if (startPara !== undefined) {
        const endNum = endPara ?? startPara;
        filteredParagraphs = paragraphs.filter((p: { num: number }) => p.num >= startPara && p.num <= endNum);
      }

      const results: Array<{ paragraph: number; text: string; matches: any }> = [];
      const seenParaNums = new Set<number>();

      for (const para of filteredParagraphs) {
        // Deduplicate by paragraph number - same paragraph can appear multiple times
        // if the DOM has duplicate .pali-paragraph elements with the same number
        if (seenParaNums.has(para.num)) continue;
        seenParaNums.add(para.num);

        // Pass sourceRef to properly filter out self-matching (same sutta + same paragraph)
        const sourceRef = currentSuttaId ? { suttaId: currentSuttaId, paragraphNum: para.num } : undefined;
        const matches = findMatches(para.text, para.text, currentSuttaId, sourceRef);
        results.push({
          paragraph: para.num,
          text: para.text.substring(0, 100) + (para.text.length > 100 ? '...' : ''),
          matches: matches ? {
            totalDiscourses: matches.totalDiscourses,
            phraseGroups: matches.phraseGroups.length,
            groups: matches.phraseGroups.map(pg => ({
              matchedSegment: pg.matchedSegment, // The actual matched segment from source
              words: pg.matchedWordCount,        // Segment length (including repeated words)
              segmentWords: pg.matchedSegment.split(/\s+/).length, // Actual words in segment string
              contentWords: pg.contentWordCount, // Non-stop words count
              uniqueWords: pg.matchedWords.size, // Unique words (for highlighting)
              discourses: pg.totalCount,
              score: pg.score,
              wordRange: `${pg.startIndex}-${pg.endIndex}`,
              rangeLength: (pg.endIndex !== undefined && pg.startIndex !== undefined)
                ? pg.endIndex - pg.startIndex + 1 : 0,
              coveredCount: pg.coveredPositions ?
                (pg.coveredPositions instanceof Set ? pg.coveredPositions.size : (pg.coveredPositions as number[]).length) : 0,
              firstMatch: pg.diverseDiscourses[0] ?
                `${pg.diverseDiscourses[0].suttaId}.${pg.diverseDiscourses[0].paragraphNum}` : null,
            })),
          } : null,
        });
      }

      console.log(JSON.stringify(results, null, 2));
      return results;
    },

    // Debug why a specific phrase isn't matching
    // Usage: tmDebug.checkPhrase("kāyaparihārikena cīvarena kucchiparihārikena piṇḍapātena")
    checkPhrase: (phrase: string) => {
      if (!tmIndex) {
        console.warn('[TM Debug] Index not loaded. Call loadIndex() first.');
        return null;
      }

      const ngramSize = tmIndex.ngramSize || 4;
      const normalized = normalizePali(phrase);
      const words = normalized.split(/\s+/).filter(w => w.length > 0);
      const ngrams = extractNgrams(words, ngramSize);

      console.log(`[TM Debug] Checking phrase: "${phrase}"`);
      console.log(`[TM Debug] Normalized: "${normalized}"`);
      console.log(`[TM Debug] Words (${words.length}): ${JSON.stringify(words)}`);
      console.log(`[TM Debug] N-grams (${ngrams.length}) for n=${ngramSize}:`);

      const results: Array<{ ngram: string; found: boolean; entryCount: number; entries?: Array<{ id: number; suttaId: string; paragraphNum: number }> }> = [];

      for (const ngram of ngrams) {
        const entryIds = tmIndex.ngrams?.[ngram];
        const found = !!entryIds && entryIds.length > 0;

        let entries: Array<{ id: number; suttaId: string; paragraphNum: number }> | undefined;
        if (found && entryIds.length <= 5) {
          // Show details for small result sets
          entries = entryIds.map(id => {
            const entry = tmIndex!.entries[id];
            return {
              id,
              suttaId: entry?.source?.suttaId || 'unknown',
              paragraphNum: entry?.source?.paragraphNum || 0,
            };
          });
        }

        results.push({
          ngram,
          found,
          entryCount: entryIds?.length || 0,
          entries,
        });

        console.log(`  "${ngram}" -> ${found ? `FOUND (${entryIds.length} entries)` : 'NOT FOUND'}`);
      }

      return results;
    },

    // Debug the full matching process for a paragraph
    // Usage: tmDebug.debugParagraph(21)
    debugParagraph: async (paraNum: number) => {
      const loaded = await loadTMIndex();
      if (!loaded) {
        console.warn('[TM Debug] Failed to load index');
        return null;
      }

      const currentSuttaId = getCurrentSuttaId();
      const paragraphs = (window as any).tmDebug.getPaliParagraphs();
      const para = paragraphs.find((p: { num: number }) => p.num === paraNum);

      if (!para) {
        console.warn(`[TM Debug] Paragraph ${paraNum} not found`);
        return null;
      }

      const ngramSize = tmIndex!.ngramSize || 4;
      const queryNormalized = normalizePali(para.text);
      const queryWords = queryNormalized.split(/\s+/).filter((w: string) => w.length > 0);
      const queryNgrams = extractNgrams(queryWords, ngramSize);

      console.log(`[TM Debug] === Debugging Paragraph ${paraNum} ===`);
      console.log(`[TM Debug] Raw text: "${para.text.substring(0, 150)}..."`);
      console.log(`[TM Debug] Normalized: "${queryNormalized.substring(0, 150)}..."`);
      console.log(`[TM Debug] Word count: ${queryWords.length}`);
      console.log(`[TM Debug] First 10 words: ${JSON.stringify(queryWords.slice(0, 10))}`);
      console.log(`[TM Debug] N-gram count: ${queryNgrams.length} (size=${ngramSize})`);

      // Check each n-gram in the index
      let matchedNgramCount = 0;
      const candidateEntryIds = new Set<number>();
      const ngramDetails: Array<{ ngram: string; found: boolean; count: number }> = [];

      for (const ngram of queryNgrams) {
        const entryIds = tmIndex!.ngrams?.[ngram];
        const found = !!entryIds && entryIds.length > 0;
        if (found) {
          matchedNgramCount++;
          // Filter out self-sutta
          const filteredIds = entryIds.filter(id => {
            const entry = tmIndex!.entries[id];
            return entry && entry.source.suttaId !== currentSuttaId;
          });
          filteredIds.forEach(id => candidateEntryIds.add(id));
        }
        ngramDetails.push({ ngram, found, count: entryIds?.length || 0 });
      }

      console.log(`[TM Debug] Matched n-grams: ${matchedNgramCount}/${queryNgrams.length}`);
      console.log(`[TM Debug] Candidate entries (after self-filter): ${candidateEntryIds.size}`);

      // Show first 5 unmatched n-grams
      const unmatchedNgrams = ngramDetails.filter(d => !d.found).slice(0, 5);
      if (unmatchedNgrams.length > 0) {
        console.log(`[TM Debug] First unmatched n-grams: ${JSON.stringify(unmatchedNgrams.map(d => d.ngram))}`);
      }

      // Show first 5 matched n-grams with their entry counts
      const matchedNgrams = ngramDetails.filter(d => d.found).slice(0, 5);
      if (matchedNgrams.length > 0) {
        console.log(`[TM Debug] First matched n-grams: ${JSON.stringify(matchedNgrams)}`);
      }

      // Show candidate entries with per-entry n-gram counts
      if (candidateEntryIds.size > 0 && candidateEntryIds.size <= 10) {
        // Build a map of entryId -> count of matching n-grams
        const entryNgramCounts = new Map<number, number>();
        for (const ngram of queryNgrams) {
          const entryIds = tmIndex!.ngrams?.[ngram];
          if (entryIds) {
            for (const id of entryIds) {
              if (candidateEntryIds.has(id)) {
                entryNgramCounts.set(id, (entryNgramCounts.get(id) || 0) + 1);
              }
            }
          }
        }

        const entryDetails = [...candidateEntryIds].map(id => {
          const entry = tmIndex!.entries[id];
          return {
            id,
            suttaId: entry?.source?.suttaId,
            para: entry?.source?.paragraphNum,
            matchingNgrams: entryNgramCounts.get(id) || 0,
          };
        });
        console.log(`[TM Debug] Candidate entries: ${JSON.stringify(entryDetails)}`);
      }

      return {
        paraNum,
        wordCount: queryWords.length,
        ngramCount: queryNgrams.length,
        matchedNgrams: matchedNgramCount,
        candidateEntries: candidateEntryIds.size,
        ngramDetails: ngramDetails.slice(0, 20),
      };
    },
  };

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initialize);
  } else {
    // Small delay to ensure content is rendered
    setTimeout(initialize, 100);
  }
</script>
)}
