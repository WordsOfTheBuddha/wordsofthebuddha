---
import { app } from "../firebase/server";
import { getAuth } from "firebase-admin/auth";
import CopyButton from "./CopyButton.astro";

// Get authentication status
let isAuthenticated = false;
if (Astro.cookies.has("__session")) {
	const sessionCookie = Astro.cookies.get("__session")?.value;
	if (sessionCookie) {
		const auth = getAuth(app);
		try {
			await auth.verifySessionCookie(sessionCookie);
			isAuthenticated = true;
		} catch (error) {
			// Invalid cookie
		}
	}
}

// HighlightLayout.astro
const currentPath = Astro.url.pathname;

const COLOR_MAP = {
	yellow: "#FEF08A",
	pink: "#FBCFE8",
	green: "#BBF7D0",
	blue: "#BFDBFE",
} as const;

// Add blacklist for pages where highlighting should be disabled
const HIGHLIGHT_BLACKLIST = [
	"/dashboard",
	"/search",
	"/profile",
	"/signin",
	"/register",
	"/about",
];

const isHighlightingDisabled = HIGHLIGHT_BLACKLIST.some((path) =>
	currentPath.startsWith(path)
);

const { title, description } = Astro.props;
---

<div
	id="highlight-root"
	class:list={["highlight-container"]}
	data-authenticated={isAuthenticated}
	data-title={title}
	data-description={description}
	data-highlight-disabled={isHighlightingDisabled}
>
	<slot />

	<div id="highlight-menu" class="highlight-menu" style="display: none;">
		<div class="menu-items">
			<CopyButton />
			{
				Object.entries(COLOR_MAP).map(([colorName, bgColor]) => (
					<button
						data-color={colorName}
						style={`background-color: ${bgColor}`}
						class="color-swatch"
					/>
				))
			}
			<button id="highlight-eraser" class="eraser-btn" style="display: none;">
				<svg
					xmlns="http://www.w3.org/2000/svg"
					viewBox="0 0 32 32"
					width="16"
					height="16"
				>
					<path
						fill="currentColor"
						d="M28.7 8.9l-5.7-5.7c-1.1-1.1-3.1-1.1-4.2 0l-7.1 7.1c0 0 0 0 0 0s0 0 0 0l-7.5 7.5c-1.2 1.2-1.2 3.1 0 4.2l3.8 3.8c0.2 0.2 0.4 0.3 0.7 0.3h6.6c0.3 0 0.5-0.1 0.7-0.3l12.7-12.7c0 0 0 0 0 0C29.9 12 29.9 10.1 28.7 8.9zM14.9 24.1H9.2l-3.5-3.5c-0.4-0.4-0.4-1 0-1.4l6.8-6.8l7.1 7.1L14.9 24.1z"
					></path>
					<path
						fill="currentColor"
						d="M27 28H5c-0.6 0-1 0.4-1 1s0.4 1 1 1h22c0.6 0 1-0.4 1-1S27.6 28 27 28z"
					></path>
				</svg>
			</button>
		</div>
	</div>

	<!-- Sign in prompt -->
	<div id="highlight-signin" class="highlight-signin" style="display: none;">
		<a href={`/signin?returnTo=${currentPath}`} class="signin-link"
			>Sign in to highlight and add notes</a
		>
	</div>
</div>

<style>
	:global(.highlight-container) {
		position: relative;
	}

	:global(.highlight-menu) {
		position: absolute;
		left: 0;
		top: 0;
		background: var(--bg-color, #fff);
		border: 1px solid var(--border-color, #e5e7eb);
		opacity: 1 !important;
		border-radius: 6px;
		padding: 8px;
		box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
		transform: none;
		transition: all 0.2s;
		z-index: 9998;
		pointer-events: none;
	}

	:global(.dark .highlight-menu) {
		--bg-color: #1f2937;
		--border-color: #374151;
	}

	:global(.highlight-menu .menu-items) {
		display: flex;
		align-items: center;
		gap: 8px;
		pointer-events: all;
	}

	:global(.color-swatch) {
		width: 24px;
		height: 24px;
		border: none;
		border-radius: 50%;
		cursor: pointer;
		transition: transform 0.2s;
		padding: 0;
		flex-shrink: 0;
	}

	:global(.color-swatch:hover) {
		transform: scale(1.1);
	}

	:global(.menu-items) {
		display: flex;
		align-items: center;
		gap: 8px;
		pointer-events: all;
	}

	:global(.eraser-btn) {
		width: 24px;
		height: 24px;
		min-width: 24px;
		border: none;
		border-radius: 50%;
		background: #999;
		color: white;
		cursor: pointer;
		display: inline-flex;
		align-items: center;
		justify-content: center;
		padding: 0;
		flex-shrink: 0;
	}

	:global(.eraser-btn:hover) {
		background: #777;
	}

	:global(mark) {
		border-radius: 2px;
		padding: 0 2px;
	}

	:global(.highlight-yellow) {
		background-color: #fef08a;
	}
	:global(.highlight-pink) {
		background-color: #fbcfe8;
	}
	:global(.highlight-green) {
		background-color: #bbf7d0;
	}
	:global(.highlight-blue) {
		background-color: #bfdbfe;
	}

	.highlight-signin {
		position: absolute;
		left: 0;
		top: 0;
		background: var(--menu-bg, #fff);
		border: 1px solid var(--menu-border, #ccc);
		border-radius: 6px;
		padding: 8px 12px;
		box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
		z-index: 9999;
		font-size: 0.875rem;
		pointer-events: all;
		width: fit-content;
	}

	.signin-link {
		color: var(--text-color);
		text-decoration: none;
	}

	.signin-link:hover {
		text-decoration: underline;
	}

	:global(.dark-mode .highlight-signin) {
		--menu-bg: #333;
		--menu-border: #555;
	}
</style>

<script>
	// Remove duplicate interface definitions since they're now in rangy.d.ts
	declare global {
		interface Window {
			rangy: RangyStatic;
		}
	}

	// Import rangy dynamically to ensure proper typing
	const importRangy = async () => {
		const rangy = (await import("rangy")).default;
		await import("rangy/lib/rangy-classapplier");
		await import("rangy/lib/rangy-highlighter");
		await import("rangy/lib/rangy-selectionsaverestore");
		return rangy;
	};

	let highlighter: Highlighter | null = null;
	let currentRange: Range | null = null;
	const storageKey = `my-highlights-${window.location.pathname}`;
	let menu = document.getElementById("highlight-menu") as HTMLDivElement;
	let rootElement: HTMLElement | null = null;

	// Mobile detection and range preservation
	let isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
	let savedRange: Range | null = null;
	let isMouseDown = false;
	let menuPositionTimeout: number | null = null;

	const COLOR_MAP = {
		yellow: "#FEF08A",
		pink: "#FBCFE8",
		green: "#BBF7D0",
		blue: "#BFDBFE",
	} as const;

	type ColorName = keyof typeof COLOR_MAP;

	// Theme handling
	function updateDarkMode(): void {
		if (!rootElement) rootElement = document.getElementById("highlight-root");
		if (!rootElement) return;

		const isDark = document.documentElement.classList.contains("dark");
		if (isDark) {
			rootElement.classList.add("dark-mode");
		} else {
			rootElement.classList.remove("dark-mode");
		}
	}

	function updateTheme(): void {
		const isDark = document.documentElement.classList.contains("dark");
		if (menu) {
			menu.style.setProperty("--bg-color", isDark ? "#1f2937" : "#fff");
			menu.style.setProperty("--border-color", isDark ? "#374151" : "#e5e7eb");
		}
	}

	// Initialize everything after Rangy is loaded
	async function initializeHighlighter(): Promise<void> {
		try {
			const rangy = await importRangy();
			window.rangy = rangy;
			rangy.init();
			highlighter = rangy.createHighlighter();

			Object.entries(COLOR_MAP).forEach(([colorName, bgColor]) => {
				const applier = rangy.createClassApplier(`highlight-${colorName}`, {
					elementTagName: "mark",
					splitExisting: true,
					normalize: true,
				});
				if (highlighter) {
					highlighter.addClassApplier(applier);
				}
			});

			// Set up event listeners first
			setupEventListeners();

			// Then fetch and restore highlights from Firestore
			await fetchHighlights();
		} catch (error) {
			console.error("Failed to initialize Rangy:", error);
		}
	}

	function isSelectionValid(selection: RangySelection) {
		if (!selection.rangeCount) return false;

		const range = selection.getRangeAt(0).nativeRange;
		if (!range) return false;

		// Check for text content
		const textContent = range.toString().trim();
		if (textContent.length === 0) return false;

		// Get containers
		const containers = getAllHighlightContainers(range);
		console.log("Found containers for selection:", {
			containerCount: containers.length,
			containers: containers.map((c) => ({
				type: c.tagName,
				text: c.textContent?.substring(0, 50) + "...",
			})),
		});

		return containers.length > 0;
	}

	function calculateMenuPosition(
		menu: HTMLElement,
		finalRect: DOMRect,
		rootElement: HTMLElement
	) {
		const containerRect = rootElement.getBoundingClientRect();
		const menuLeft =
			finalRect.right - containerRect.left + rootElement.scrollLeft + 5;
		const maxLeft = containerRect.width - menu.offsetWidth;
		menu.style.left = `${Math.min(menuLeft, maxLeft)}px`;
		menu.style.top = `${finalRect.bottom - containerRect.top + rootElement.scrollTop}px`;
	}

	function handleSelection(e: MouseEvent | TouchEvent) {
		if (!window.rangy || !highlighter) return;

		// Check if highlighting is disabled for this page
		if (rootElement?.dataset.highlightDisabled === "true") {
			return;
		}

		// Hide both menus initially
		menu.style.display = "none";
		document.getElementById("highlight-signin")!.style.display = "none";

		const target = e.target as HTMLElement;
		const selection = window.rangy.getSelection();

		// Log selection details for debugging
		console.log("Selection details:", {
			isCollapsed: selection.isCollapsed,
			hasRange: selection.rangeCount > 0,
			text: selection.toString().trim(),
		});

		// Early return if no valid selection
		if (selection.isCollapsed || !selection.rangeCount) return;

		// Check if target is inside a tooltip
		if (target.closest(".tooltip-text") || target.closest(".tippy-content")) {
			menu.style.display = "none";
			return;
		}

		// Validate selection and get containers
		if (!isSelectionValid(selection)) {
			console.log("Invalid selection");
			return;
		}

		// Get Pali context
		const isPaliParagraph = target.closest(".pali-paragraph");
		const isPaliLookupEnabled = localStorage.getItem("paliLookup") === "true";
		const selectedText = selection.toString().trim();
		const isSingleWord = selectedText && !selectedText.includes(" ");

		// Only hide menu if ALL three conditions are met
		if (isPaliLookupEnabled && isPaliParagraph && isSingleWord) {
			menu.style.display = "none";
			return;
		}

		// Rest of the existing checks
		if (e instanceof MouseEvent && isMouseDown) return;

		if (selection.isCollapsed || !isSelectionValid(selection)) {
			menu.style.display = "none";
			document.getElementById("highlight-signin")!.style.display = "none";
			return;
		}

		// Get authentication status
		const isAuthenticated = rootElement?.dataset.authenticated === "true";

		// Handle Pali lookup cases
		if (isPaliLookupEnabled && isPaliParagraph && isSingleWord) {
			menu.style.display = "none";
			document.getElementById("highlight-signin")!.style.display = "none";
			return;
		}

		// Show appropriate menu based on auth status
		if (!isAuthenticated) {
			const signinPrompt = document.getElementById("highlight-signin")!;
			updateMenuPosition(selection, signinPrompt);
			return;
		}

		// Show highlight menu for authenticated users
		menu.style.display = "block";
		updateMenuPosition(selection, menu);
	}

	function updateMenuPosition(
		selection: RangySelection,
		element: HTMLElement = menu
	) {
		// Early return if no valid selection
		if (!selection?.rangeCount) {
			element.style.display = "none";
			return;
		}

		const range = selection.getRangeAt(0).nativeRange;
		if (!range) {
			element.style.display = "none";
			return;
		}

		currentRange = range;
		savedRange = range.cloneRange();

		// Get the end point of the selection
		const endRange = document.createRange();
		endRange.setStart(range.endContainer, range.endOffset);
		endRange.collapse(true); // Collapse to end point

		// Get the position of the last character in the selection
		const endRects = endRange.getClientRects();
		let finalRect: DOMRect | null = null;

		if (endRects.length > 0) {
			// Use the last visible cursor position at selection end
			finalRect = endRects[endRects.length - 1];
		} else {
			// Fallback to first rect in selection
			const rects = currentRange.getClientRects();
			if (rects.length > 0) {
				finalRect = rects[rects.length - 1];
			} else {
				finalRect = currentRange.getBoundingClientRect();
			}
		}

		// Validate rootElement first
		if (!rootElement) {
			menu.style.display = "none";
			return;
		}

		if (!isSelectionValid(selection)) {
			menu.style.display = "none";
			return;
		}

		if (finalRect) {
			calculateMenuPosition(element, finalRect, rootElement!);
		}

		element.style.display = "block";

		// Add back the eraser visibility check
		const eraser = document.getElementById("highlight-eraser");
		if (eraser && highlighter) {
			// Get fresh selection reference after potential range adjustments
			const currentSelection = window.rangy.getSelection();
			const existing = highlighter.getHighlightsInSelection(currentSelection);
			eraser.style.display = existing.length > 0 ? "flex" : "none";
		}

		// Keep existing outside click listener logic
		outsideClickListener = (e: MouseEvent) => {
			const target = e.target as Node;
			if (!menu.contains(target)) {
				menu.style.display = "none";
				window.getSelection()?.removeAllRanges();
				document.removeEventListener("mousedown", outsideClickListener!);
			}
		};
		document.addEventListener("mousedown", outsideClickListener);
	}

	function handleSelectionChange() {
		if (!window.rangy || !highlighter) return;

		// Hide the menu whenever the selection is actively changing
		menu.style.display = "none";

		const selection = window.rangy.getSelection();
		// If no selection, nothing else to do
		if (selection.isCollapsed || selection.rangeCount === 0) {
			return;
		}

		// We don't reposition or show the menu here
		// because we only want it visible after mouseup or touchend
	}

	function applyHighlight(colorName: ColorName): void {
		if (!highlighter || !window.rangy) return;

		const selection = window.rangy.getSelection();

		if (isMobile && savedRange) {
			setTimeout(() => {
				try {
					selection.removeAllRanges();
					selection.addRange(savedRange!);
					selection.refresh();
					applyHighlightToSelection(colorName, selection);
				} catch (e) {
					console.log("Range restoration error:", e);
				}
			}, 100);
		} else {
			applyHighlightToSelection(colorName, selection);
		}
	}

	function applyHighlightToSelection(
		colorName: ColorName,
		selection: RangySelection
	) {
		if (!selection.rangeCount) return;

		highlighter!.highlightSelection(`highlight-${colorName}`, {
			selection: selection,
			containerElementId: "highlight-root",
			exclusive: true, // Remove existing highlights in selection
		});

		persist();
		menu.style.display = "none";

		if (!isMobile) {
			window.getSelection()?.removeAllRanges();
		}
	}

	function handleClear(): void {
		if (!highlighter || !window.rangy) return;

		const selection = window.rangy.getSelection();

		if (isMobile && savedRange) {
			try {
				selection.removeAllRanges();
				selection.addRange(savedRange);
				selection.refresh();
			} catch (e) {
				console.log("Clear range error:", e);
				return;
			}
		}

		const existing = highlighter.getHighlightsInSelection(selection);
		if (existing.length > 0) {
			highlighter.removeHighlights(existing);

			// Get the updated state after removal
			const updatedRangyHash = highlighter.serialize();
			persist(updatedRangyHash, "delete");
		}

		if (!isMobile) {
			window.getSelection()?.removeAllRanges();
		}

		menu.style.display = "none";
	}

	function persist(
		rangyHash?: string,
		operation: "add" | "delete" = "add"
	): void {
		if (!highlighter) return;
		const serialized = rangyHash || highlighter.serialize();
		persistToFirestore(serialized);
	}

	function getAllHighlightContainers(range: Range): Element[] {
		const containers = new Set<Element>();
		const validContainers = [
			"p",
			"div",
			"h1",
			"h2",
			"h3",
			"h4",
			"h5",
			"h6",
			"li",
			"table",
		];

		// Start from the common ancestor of the selection
		const commonAncestor = range.commonAncestorContainer;
		const rootElement = document.getElementById("highlight-root");

		// If the common ancestor is not an element, get its parent
		const startContainer =
			commonAncestor.nodeType === Node.TEXT_NODE
				? commonAncestor.parentElement
				: (commonAncestor as Element);

		if (!startContainer || !rootElement) return [];

		// Get all elements between start and end of range
		const elements = document.createNodeIterator(
			startContainer,
			NodeFilter.SHOW_ELEMENT,
			{
				acceptNode: (node) => {
					if (range.intersectsNode(node)) {
						return NodeFilter.FILTER_ACCEPT;
					}
					return NodeFilter.FILTER_SKIP;
				},
			}
		);

		let current: Element | null = elements.nextNode() as Element;
		while (current) {
			// Check for table cells first
			if (
				current.tagName.toLowerCase() === "td" ||
				current.tagName.toLowerCase() === "th"
			) {
				const table = current.closest("table");
				if (table && !table.id.includes("highlight-root")) {
					containers.add(table);
				}
			} else {
				// For other elements, find the closest valid container
				const container = current.closest(validContainers.join(","));
				if (
					container &&
					!container.id.includes("highlight-root") &&
					container.contains(current) &&
					rootElement.contains(container)
				) {
					containers.add(container);
				}
			}
			current = elements.nextNode() as Element;
		}

		return Array.from(containers);
	}

	interface HighlightInfo {
		text: string;
		color: string;
		index: number;
	}

	function extractHighlightedText(container: Element): string {
		// Parse the container HTML to access DOM methods
		const parser = new DOMParser();
		const doc = parser.parseFromString(container.outerHTML, "text/html");
		const containerEl = doc.body.firstElementChild;
		if (!containerEl) return "";

		// Get all highlight marks in order
		const highlights: HighlightInfo[] = [];
		const marks = containerEl.querySelectorAll("mark");

		marks.forEach((mark, index) => {
			const color = Array.from(mark.classList)
				.find((cls) => cls.startsWith("highlight-"))
				?.replace("highlight-", "");
			if (color) {
				highlights.push({
					text: mark.textContent || "",
					color,
					index,
				});
			}
		});

		if (highlights.length === 0) return "";

		// Group continuous segments of same color
		const segments: string[] = [];
		let currentGroup: HighlightInfo[] = [highlights[0]];

		for (let i = 1; i < highlights.length; i++) {
			const current = highlights[i];
			const prev = highlights[i - 1];

			// Check if segments are continuous (adjacent indices and same color)
			if (current.color === prev.color && current.index === prev.index + 1) {
				currentGroup.push(current);
			} else {
				// Add completed group and start new one
				segments.push(currentGroup.map((h) => h.text).join(" "));
				currentGroup = [current];
			}
		}
		// Add the last group
		segments.push(currentGroup.map((h) => h.text).join(" "));

		return segments.join(" ... ");
	}

	async function persistToFirestore(rangyHash: string): Promise<void> {
		console.log("Starting highlight persistence", { rangyHash });

		const highlightedContainers = scanPageForHighlights();
		console.log("Found highlighted containers:", highlightedContainers.length);

		if (highlightedContainers.length === 0) {
			console.log("No highlights remain, deleting highlight doc");
			const slug = getSlug();
			try {
				await fetch("/api/highlights/delete", {
					method: "POST",
					headers: { "Content-Type": "application/json" },
					body: JSON.stringify({ slug }),
				});
			} catch (error) {
				console.error("Error deleting highlights:", error);
			}
			return;
		}

		// Build highlight segments
		const highlightSegments: { [key: string]: any } = {};
		highlightedContainers.forEach(({ containerIndex, container, order }) => {
			const highlightText = extractHighlightedText(container);
			if (highlightText) {
				highlightSegments[containerIndex] = {
					containerHTML: container.outerHTML,
					highlightText,
					domPath: getDomPath(container),
					order,
				};
				console.log("Saving container:", {
					index: containerIndex,
					order,
					text: container.textContent?.substring(0, 50) + "...",
					highlightText,
				});
			}
		});

		const slug = getSlug();
		const highlight = {
			slug,
			title: document.getElementById("highlight-root")?.dataset.title || "",
			description:
				document.getElementById("highlight-root")?.dataset.description || "",
			rangyHash,
			highlightSegments,
			updatedAt: new Date() as any, // Will be converted to Timestamp in Firestore
		};

		try {
			const response = await fetch("/api/highlights/add", {
				method: "POST",
				headers: { "Content-Type": "application/json" },
				body: JSON.stringify({
					slug,
					highlights: highlight,
				}),
			});
			const data = await response.json();
			console.log("Server response:", data);

			if (data.error) {
				console.error("Server reported error:", data.error);
			}
		} catch (error) {
			console.error("Error persisting highlights:", error);
		}
	}

	async function fetchHighlights(): Promise<void> {
		try {
			const slug = getSlug();
			console.log("Fetching highlights for:", slug);

			const response = await fetch(
				`/api/highlights/get?slug=${encodeURIComponent(slug)}`
			);
			const data = await response.json();

			console.log("Received highlights:", {
				opId: data.opId,
				hasHighlights: !!data.highlights?.rangyHash,
			});

			if (data.highlights?.rangyHash && highlighter) {
				console.log("Deserializing highlights");
				highlighter.deserialize(data.highlights.rangyHash);
			}
		} catch (error) {
			console.error("Error fetching highlights:", error);
		}
	}

	function setupSwatchListeners() {
		document
			.querySelectorAll<HTMLButtonElement>(".color-swatch")
			.forEach((swatch) => {
				swatch.addEventListener("touchend", (e) => {
					e.preventDefault();
					const colorName = swatch.dataset.color as ColorName;
					if (colorName) applyHighlight(colorName);
				});
				swatch.addEventListener("click", () => {
					const colorName = swatch.dataset.color as ColorName;
					if (colorName) applyHighlight(colorName);
				});
			});
	}

	function setupEventListeners(): void {
		document.addEventListener("mousedown", () => {
			isMouseDown = true;
		});
		document.addEventListener("mouseup", handleMouseUp);
		document.addEventListener("touchend", handleSelection);
		document.addEventListener("selectionchange", handleSelectionChange);
		setupSwatchListeners();
		const eraserBtn = document.getElementById("highlight-eraser");
		if (eraserBtn) {
			eraserBtn.addEventListener("click", handleClear);
			eraserBtn.addEventListener("touchend", handleClear);
		}
	}

	let outsideClickListener: ((e: MouseEvent) => void) | null = null;

	function handleMouseUp(e: MouseEvent) {
		isMouseDown = false;
		handleSelection(e);
	}

	const getSlug = () => {
		const url = new URL(window.location.href);
		// Get path without hash
		const basePath = url.pathname;
		// Only consider pli parameter
		const pliParam = url.searchParams.get("pli");
		// Ignore other parameters and hash
		return pliParam ? `${basePath}?pli=true` : basePath;
	};

	const noteId = localStorage.getItem("noteId"); // Assuming noteId is stored in localStorage

	function getHighlightContainer(element: Element | null): Element | null {
		if (!element) return null;

		// Valid container elements
		const validContainers = [
			"p",
			"div",
			"h1",
			"h2",
			"h3",
			"h4",
			"h5",
			"h6",
			"li",
			"table",
		];

		let current = element;
		while (current && current.parentElement) {
			// Stop if we hit the highlight root
			if (current.id === "highlight-root") return null;

			// Special handling for table cells
			if (
				current.tagName.toLowerCase() === "td" ||
				current.tagName.toLowerCase() === "th"
			) {
				const table = current.closest("table");
				if (table && (table.textContent?.length || 0) <= 1000) {
					return table;
				}
			}

			// Check if current element is a valid container
			if (validContainers.includes(current.tagName.toLowerCase())) {
				// Don't select containers that are too large
				const text = current.textContent || "";
				if (text.length <= 1000) {
					return current;
				}
			}
			current = current.parentElement;
		}
		return null;
	}

	function getContainerIndex(element: Element): string {
		// Get type of container (p, div, h1, etc)
		const type = element.tagName.toLowerCase();
		// Find all elements of same type
		const sameTypeElements = Array.from(document.getElementsByTagName(type));
		// Get index of our element
		const index = sameTypeElements.indexOf(element);
		return `${type}-${index}`;
	}

	function getDomPath(element: Element): string {
		const path: number[] = [];
		while (element && element.parentElement) {
			const parent = element.parentElement;
			const index = Array.from(parent.children).indexOf(element);
			path.unshift(index);
			element = parent;
		}
		return path.join("-");
	}

	function scanPageForHighlights(): {
		containerIndex: string;
		container: Element;
		order: number;
	}[] {
		const validContainers = [
			"p",
			"div",
			"h1",
			"h2",
			"h3",
			"h4",
			"h5",
			"h6",
			"li",
			"table",
		];
		const root = document.getElementById("highlight-root");
		if (!root) return [];

		console.log("Starting page scan");

		// First, find all highlighted elements
		const highlightedElements = Array.from(
			root.querySelectorAll('mark[class*="highlight-"]')
		);
		console.log("Found highlighted marks:", highlightedElements.length);

		// Get their containers
		const containers = new Set<Element>();
		highlightedElements.forEach((mark) => {
			for (
				let el = mark.parentElement;
				el && el !== root;
				el = el.parentElement
			) {
				if (validContainers.includes(el.tagName.toLowerCase())) {
					containers.add(el);
					break; // Stop at first valid container
				}
			}
		});

		console.log("Found containers:", containers.size);

		// Convert to array and sort by document position
		const orderedContainers = Array.from(containers);
		orderedContainers.sort((a, b) => {
			const position = a.compareDocumentPosition(b);
			return position & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : 1;
		});

		// Map to result format
		const results = orderedContainers.map((container, index) => ({
			containerIndex: getContainerIndex(container),
			container,
			order: index,
		}));

		// Debug log
		results.forEach(({ container, order }) => {
			console.log("Container in order:", {
				tag: container.tagName,
				order,
				text: container.textContent?.substring(0, 50) + "...",
				highlights: container.querySelectorAll('mark[class*="highlight-"]')
					.length,
			});
		});

		return results;
	}

	// Initialize on page load
	document.addEventListener("DOMContentLoaded", () => {
		rootElement = document.getElementById("highlight-root");
		menu = document.getElementById("highlight-menu") as HTMLDivElement;
		updateDarkMode(); // Initial theme state
		updateTheme(); // Initial theme colors
		window.addEventListener("themeToggled", updateDarkMode);
		document.addEventListener("themeChanged", updateTheme);
		initializeHighlighter();
	});
</script>
