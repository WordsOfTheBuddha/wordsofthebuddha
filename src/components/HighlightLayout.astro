---
// HighlightLayout.astro
const { currentPath } = Astro.props;

const COLOR_MAP = {
	yellow: "#FEF08A",
	pink: "#FBCFE8",
	green: "#BBF7D0",
	blue: "#BFDBFE",
} as const;

type ColorName = keyof typeof COLOR_MAP;
---

<div id="highlight-root" class:list={["highlight-container"]}>
	<slot />

	<div
		id="highlight-menu"
		class="highlight-menu"
		style="display: none; --x: 0; --y: 0;"
	>
		{
			Object.entries(COLOR_MAP).map(([colorName, bgColor]) => (
				<button
					data-color={colorName}
					style={`background-color: ${bgColor}`}
					class="color-swatch"
				/>
			))
		}
		<button id="highlight-eraser" class="eraser-btn" style="display: none;">
			<svg
				xmlns="http://www.w3.org/2000/svg"
				viewBox="0 0 32 32"
				width="16"
				height="16"
			>
				<path
					fill="currentColor"
					d="M28.7 8.9l-5.7-5.7c-1.1-1.1-3.1-1.1-4.2 0l-7.1 7.1c0 0 0 0 0 0s0 0 0 0l-7.5 7.5c-1.2 1.2-1.2 3.1 0 4.2l3.8 3.8c0.2 0.2 0.4 0.3 0.7 0.3h6.6c0.3 0 0.5-0.1 0.7-0.3l12.7-12.7c0 0 0 0 0 0C29.9 12 29.9 10.1 28.7 8.9zM14.9 24.1H9.2l-3.5-3.5c-0.4-0.4-0.4-1 0-1.4l6.8-6.8l7.1 7.1L14.9 24.1z"
				></path>
				<path
					fill="currentColor"
					d="M27 28H5c-0.6 0-1 0.4-1 1s0.4 1 1 1h22c0.6 0 1-0.4 1-1S27.6 28 27 28z"
				></path>
			</svg>
		</button>
	</div>
</div>

<style>
	:global(.highlight-container) {
		position: relative;
	}

	:global(.highlight-menu) {
		position: absolute;
		left: 0;
		top: 0;
		background: var(--menu-bg, #fff);
		border: 1px solid var(--menu-border, #ccc);
		opacity: 1 !important;
		border-radius: 6px;
		padding: 8px;
		display: flex;
		gap: 8px;
		box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
		transform: none;
		transition: opacity 0.2s;
		z-index: 9999;
	}

	:global(.dark-mode .highlight-menu) {
		--menu-bg: #333;
		--menu-border: #555;
	}

	:global(.color-swatch) {
		width: 24px;
		height: 24px;
		border: none;
		border-radius: 50%;
		cursor: pointer;
		transition: transform 0.2s;
	}

	:global(.color-swatch:hover) {
		transform: scale(1.1);
	}

	:global(.eraser-btn) {
		width: 24px;
		height: 24px;
		border: none;
		border-radius: 50%;
		background: #999;
		color: white;
		cursor: pointer;
		display: flex;
		align-items: center;
		justify-content: center;
		padding: 0;
	}

	:global(.eraser-btn:hover) {
		background: #777;
	}

	:global(mark) {
		border-radius: 2px;
		padding: 0 2px;
	}

	:global(.highlight-yellow) {
		background-color: #fef08a;
	}
	:global(.highlight-pink) {
		background-color: #fbcfe8;
	}
	:global(.highlight-green) {
		background-color: #bbf7d0;
	}
	:global(.highlight-blue) {
		background-color: #bfdbfe;
	}
</style>

<script>
	// Remove duplicate interface definitions since they're now in rangy.d.ts
	declare global {
		interface Window {
			rangy: RangyStatic;
		}
	}

	// Import rangy dynamically to ensure proper typing
	const importRangy = async () => {
		const rangy = (await import("rangy")).default;
		await import("rangy/lib/rangy-classapplier");
		await import("rangy/lib/rangy-highlighter");
		await import("rangy/lib/rangy-selectionsaverestore");
		return rangy;
	};

	let highlighter: Highlighter | null = null;
	let currentRange: Range | null = null;
	const storageKey = `my-highlights-${window.location.pathname}`;
	const menu = document.getElementById("highlight-menu") as HTMLDivElement;
	let rootElement: HTMLElement | null = null;

	// Mobile detection and range preservation
	let isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
	let savedRange: Range | null = null;
	let isMouseDown = false;
	let menuPositionTimeout: number | null = null;

	const COLOR_MAP = {
		yellow: "#FEF08A",
		pink: "#FBCFE8",
		green: "#BBF7D0",
		blue: "#BFDBFE",
	} as const;

	type ColorName = keyof typeof COLOR_MAP;

	// Theme handling
	function updateDarkMode(): void {
		if (!rootElement) rootElement = document.getElementById("highlight-root");
		if (!rootElement) return;

		const isDark = document.documentElement.classList.contains("dark");
		if (isDark) {
			rootElement.classList.add("dark-mode");
		} else {
			rootElement.classList.remove("dark-mode");
		}
	}

	// Initialize everything after Rangy is loaded
	async function initializeHighlighter(): Promise<void> {
		try {
			const rangy = await importRangy();
			window.rangy = rangy;
			rangy.init();
			highlighter = rangy.createHighlighter();

			Object.entries(COLOR_MAP).forEach(([colorName, bgColor]) => {
				const applier = rangy.createClassApplier(`highlight-${colorName}`, {
					elementTagName: "mark",
					elementProperties: {
						style: {
							backgroundColor: bgColor,
						},
					},
					splitExisting: true,
					normalize: true,
				});
				if (highlighter) {
					highlighter.addClassApplier(applier);
				}
			});

			// Restore existing highlights
			const saved = localStorage.getItem(storageKey);
			if (saved) {
				highlighter.deserialize(saved);
			}

			// Set up event listeners
			setupEventListeners();
		} catch (error) {
			console.error("Failed to initialize Rangy:", error);
		}
	}

	function isSelectionValid(selection: RangySelection) {
		const range = selection.getRangeAt(0).nativeRange;
		if (!range) return false;
		const textContent = range.toString().trim();
		return textContent.length > 0;
	}

	function calculateMenuPosition(
		menu: HTMLDivElement,
		finalRect: DOMRect,
		rootElement: HTMLElement
	) {
		const containerRect = rootElement.getBoundingClientRect();
		const menuLeft =
			finalRect.right - containerRect.left + rootElement.scrollLeft + 5;
		const maxLeft = containerRect.width - menu.offsetWidth;
		menu.style.left = `${Math.min(menuLeft, maxLeft)}px`;
		menu.style.top = `${finalRect.bottom - containerRect.top + rootElement.scrollTop}px`;
	}

	function handleSelection(e: MouseEvent | TouchEvent) {
		if (!window.rangy || !highlighter) return;

		// Get selection first to check all conditions
		const selection = window.rangy.getSelection();
		const selectedText = selection.toString().trim();

		// Get Pali context
		const target = e.target as HTMLElement;
		const isPaliParagraph = target.closest(".pali-paragraph");
		const isPaliLookupEnabled = localStorage.getItem("paliLookup") === "true";
		const isSingleWord = selectedText && !selectedText.includes(" ");

		// Only hide menu if ALL three conditions are met
		if (isPaliLookupEnabled && isPaliParagraph && isSingleWord) {
			menu.style.display = "none";
			return;
		}

		// Rest of the existing checks
		if (e instanceof MouseEvent && isMouseDown) return;

		if (selection.isCollapsed || !isSelectionValid(selection)) {
			menu.style.display = "none";
			return;
		}

		// Rest of existing handleSelection code...
		if (menuPositionTimeout) {
			clearTimeout(menuPositionTimeout);
			menuPositionTimeout = null;
		}

		menuPositionTimeout = setTimeout(() => {
			updateMenuPosition(selection);
		}, 50) as unknown as number;
	}

	function updateMenuPosition(selection: RangySelection) {
		currentRange = selection.getRangeAt(0).nativeRange;
		savedRange = currentRange.cloneRange();

		// Get the end point of the selection
		const endRange = document.createRange();
		endRange.setStart(currentRange.endContainer, currentRange.endOffset);
		endRange.collapse(true); // Collapse to end point

		// Get the position of the last character in the selection
		const endRects = endRange.getClientRects();
		let finalRect: DOMRect | null = null;

		if (endRects.length > 0) {
			// Use the last visible cursor position at selection end
			finalRect = endRects[endRects.length - 1];
		} else {
			// Fallback to first rect in selection
			const rects = currentRange.getClientRects();
			if (rects.length > 0) {
				finalRect = rects[rects.length - 1];
			} else {
				finalRect = currentRange.getBoundingClientRect();
			}
		}

		// Validate rootElement first
		if (!rootElement) {
			menu.style.display = "none";
			return;
		}

		if (!isSelectionValid(selection)) {
			menu.style.display = "none";
			return;
		}

		if (finalRect) {
			calculateMenuPosition(menu, finalRect, rootElement!);
		}

		menu.style.display = "flex";

		// Add back the eraser visibility check
		const eraser = document.getElementById("highlight-eraser");
		if (eraser && highlighter) {
			// Get fresh selection reference after potential range adjustments
			const currentSelection = window.rangy.getSelection();
			const existing = highlighter.getHighlightsInSelection(currentSelection);
			eraser.style.display = existing.length > 0 ? "flex" : "none";
		}

		// Keep existing outside click listener logic
		outsideClickListener = (e: MouseEvent) => {
			const target = e.target as Node;
			if (!menu.contains(target)) {
				menu.style.display = "none";
				window.getSelection()?.removeAllRanges();
				document.removeEventListener("mousedown", outsideClickListener!);
			}
		};
		document.addEventListener("mousedown", outsideClickListener);
	}

	function handleSelectionChange() {
		if (!window.rangy || !highlighter) return;

		// Hide the menu whenever the selection is actively changing
		menu.style.display = "none";

		const selection = window.rangy.getSelection();
		// If no selection, nothing else to do
		if (selection.isCollapsed || selection.rangeCount === 0) {
			return;
		}

		// We don't reposition or show the menu here
		// because we only want it visible after mouseup or touchend
	}

	function applyHighlight(colorName: ColorName): void {
		if (!highlighter || !window.rangy) return;

		const selection = window.rangy.getSelection();

		if (isMobile && savedRange) {
			setTimeout(() => {
				try {
					selection.removeAllRanges();
					selection.addRange(savedRange!);
					selection.refresh();
					applyHighlightToSelection(colorName, selection);
				} catch (e) {
					console.log("Range restoration error:", e);
				}
			}, 100);
		} else {
			applyHighlightToSelection(colorName, selection);
		}
	}

	function applyHighlightToSelection(
		colorName: ColorName,
		selection: RangySelection
	) {
		if (!selection.rangeCount) return;

		highlighter!.highlightSelection(`highlight-${colorName}`, {
			selection: selection,
			containerElementId: "highlight-root",
			exclusive: true, // Remove existing highlights in selection
		});

		persist();
		menu.style.display = "none";

		if (!isMobile) {
			window.getSelection()?.removeAllRanges();
		}
	}

	function handleClear(): void {
		if (!highlighter || !window.rangy) return;

		const selection = window.rangy.getSelection();

		if (isMobile && savedRange) {
			try {
				selection.removeAllRanges();
				selection.addRange(savedRange);
				selection.refresh();
			} catch (e) {
				console.log("Clear range error:", e);
				return;
			}
		}

		const existing = highlighter.getHighlightsInSelection(selection);
		if (existing.length > 0) {
			highlighter.removeHighlights(existing);
			persist();
		}

		if (!isMobile) {
			window.getSelection()?.removeAllRanges();
		}

		menu.style.display = "none";
	}

	function persist(): void {
		if (!highlighter) return;
		localStorage.setItem(storageKey, highlighter.serialize());
	}

	function setupSwatchListeners() {
		document
			.querySelectorAll<HTMLButtonElement>(".color-swatch")
			.forEach((swatch) => {
				swatch.addEventListener("touchend", (e) => {
					e.preventDefault();
					const colorName = swatch.dataset.color as ColorName;
					if (colorName) applyHighlight(colorName);
				});
				swatch.addEventListener("click", () => {
					const colorName = swatch.dataset.color as ColorName;
					if (colorName) applyHighlight(colorName);
				});
			});
	}

	function setupEventListeners(): void {
		document.addEventListener("mousedown", () => {
			isMouseDown = true;
		});
		document.addEventListener("mouseup", handleMouseUp);
		document.addEventListener("touchend", handleSelection);
		document.addEventListener("selectionchange", handleSelectionChange);
		setupSwatchListeners();
		const eraserBtn = document.getElementById("highlight-eraser");
		if (eraserBtn) {
			eraserBtn.addEventListener("click", handleClear);
			eraserBtn.addEventListener("touchend", handleClear);
		}
	}

	let outsideClickListener: ((e: MouseEvent) => void) | null = null;

	function handleMouseUp(e: MouseEvent) {
		isMouseDown = false;
		handleSelection(e);
	}

	// Initialize on page load
	document.addEventListener("DOMContentLoaded", () => {
		rootElement = document.getElementById("highlight-root");
		updateDarkMode(); // Initial theme state
		window.addEventListener("themeToggled", updateDarkMode); // Listen on window instead of document
		initializeHighlighter();
	});
</script>
