---
// HighlightLayout.astro
const { currentPath } = Astro.props;

const COLOR_MAP = {
	yellow: "#FEF08A",
	pink: "#FBCFE8",
	green: "#BBF7D0",
	blue: "#BFDBFE",
} as const;

type ColorName = keyof typeof COLOR_MAP;
---

<div id="highlight-root" class:list={["highlight-container"]}>
	<slot />

	<div
		id="highlight-menu"
		class="highlight-menu"
		style="display: none; --x: 0; --y: 0;"
	>
		{
			Object.entries(COLOR_MAP).map(([colorName, bgColor]) => (
				<button
					data-color={colorName}
					style={`background-color: ${bgColor}`}
					class="color-swatch"
				/>
			))
		}
		<button id="highlight-eraser" class="eraser-btn" style="display: none;">
			<svg
				xmlns="http://www.w3.org/2000/svg"
				viewBox="0 0 32 32"
				width="16"
				height="16"
			>
				<path
					fill="currentColor"
					d="M28.7 8.9l-5.7-5.7c-1.1-1.1-3.1-1.1-4.2 0l-7.1 7.1c0 0 0 0 0 0s0 0 0 0l-7.5 7.5c-1.2 1.2-1.2 3.1 0 4.2l3.8 3.8c0.2 0.2 0.4 0.3 0.7 0.3h6.6c0.3 0 0.5-0.1 0.7-0.3l12.7-12.7c0 0 0 0 0 0C29.9 12 29.9 10.1 28.7 8.9zM14.9 24.1H9.2l-3.5-3.5c-0.4-0.4-0.4-1 0-1.4l6.8-6.8l7.1 7.1L14.9 24.1z"
				></path>
				<path
					fill="currentColor"
					d="M27 28H5c-0.6 0-1 0.4-1 1s0.4 1 1 1h22c0.6 0 1-0.4 1-1S27.6 28 27 28z"
				></path>
			</svg>
		</button>
	</div>
</div>

<style>
	:global(.highlight-container) {
		position: relative;
		min-height: 100vh;
	}

	:global(.highlight-menu) {
		position: fixed;
		left: 0;
		top: 0;
		background: var(--menu-bg, #fff);
		border: 1px solid var(--menu-border, #ccc);
		opacity: 1 !important;
		border-radius: 6px;
		padding: 8px;
		display: flex;
		gap: 8px;
		box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
		transform: none;
		transition: opacity 0.2s;
		z-index: 9999;
	}

	:global(.dark-mode .highlight-menu) {
		--menu-bg: #333;
		--menu-border: #555;
	}

	:global(.color-swatch) {
		width: 24px;
		height: 24px;
		border: none;
		border-radius: 50%;
		cursor: pointer;
		transition: transform 0.2s;
	}

	:global(.color-swatch:hover) {
		transform: scale(1.1);
	}

	:global(.eraser-btn) {
		width: 24px;
		height: 24px;
		border: none;
		border-radius: 50%;
		background: #999;
		color: white;
		cursor: pointer;
		display: flex;
		align-items: center;
		justify-content: center;
		padding: 0;
	}

	:global(.eraser-btn:hover) {
		background: #777;
	}

	:global(mark) {
		border-radius: 2px;
		padding: 0 2px;
	}

	:global(.highlight-yellow) {
		background-color: #fef08a;
	}
	:global(.highlight-pink) {
		background-color: #fbcfe8;
	}
	:global(.highlight-green) {
		background-color: #bbf7d0;
	}
	:global(.highlight-blue) {
		background-color: #bfdbfe;
	}
</style>

<script>
	// Remove duplicate interface definitions since they're now in rangy.d.ts
	declare global {
		interface Window {
			rangy: RangyStatic;
		}
	}

	// Import rangy dynamically to ensure proper typing
	const importRangy = async () => {
		const rangy = (await import("rangy")).default;
		await import("rangy/lib/rangy-classapplier");
		await import("rangy/lib/rangy-highlighter");
		await import("rangy/lib/rangy-selectionsaverestore");
		return rangy;
	};

	let highlighter: Highlighter | null = null;
	let currentRange: Range | null = null;
	const storageKey = `my-highlights-${window.location.pathname}`;
	const menu = document.getElementById("highlight-menu") as HTMLDivElement;
	let rootElement: HTMLElement | null = null;

	const COLOR_MAP = {
		yellow: "#FEF08A",
		pink: "#FBCFE8",
		green: "#BBF7D0",
		blue: "#BFDBFE",
	} as const;

	type ColorName = keyof typeof COLOR_MAP;

	// Theme handling
	function updateDarkMode(): void {
		if (!rootElement) rootElement = document.getElementById("highlight-root");
		if (!rootElement) return;

		if (document.documentElement.classList.contains("dark")) {
			rootElement.classList.add("dark-mode");
		} else {
			rootElement.classList.remove("dark-mode");
		}
	}

	// Initialize everything after Rangy is loaded
	async function initializeHighlighter(): Promise<void> {
		try {
			const rangy = await importRangy();
			window.rangy = rangy;
			rangy.init();
			highlighter = rangy.createHighlighter();

			Object.entries(COLOR_MAP).forEach(([colorName, bgColor]) => {
				const applier = rangy.createClassApplier(`highlight-${colorName}`, {
					elementTagName: "mark",
					elementProperties: {
						style: {
							backgroundColor: bgColor,
						},
					},
					splitExisting: true,
					normalize: true,
				});
				if (highlighter) {
					highlighter.addClassApplier(applier);
				}
			});

			// Restore existing highlights
			const saved = localStorage.getItem(storageKey);
			if (saved) {
				highlighter.deserialize(saved);
			}

			// Set up event listeners
			setupEventListeners();
		} catch (error) {
			console.error("Failed to initialize Rangy:", error);
		}
	}

	function setupEventListeners(): void {
		document.addEventListener("mouseup", handleMouseUp);
		document.addEventListener("mousedown", handleOutsideClick);

		document
			.querySelectorAll<HTMLButtonElement>(".color-swatch")
			.forEach((swatch) => {
				swatch.addEventListener("click", () => {
					const colorName = swatch.dataset.color as ColorName;
					if (colorName) {
						applyHighlight(colorName);
					}
				});
			});

		const eraserBtn = document.getElementById("highlight-eraser");
		if (eraserBtn) {
			eraserBtn.addEventListener("click", handleClear);
		}
	}

	let outsideClickListener: ((e: MouseEvent) => void) | null = null;

	function handleMouseUp(e: MouseEvent): void {
		if (!window.rangy || !highlighter) return;

		const selection = window.rangy.getSelection();
		if (selection.isCollapsed || selection.rangeCount === 0) {
			menu.style.display = "none";
			return;
		}

		// Grab the actual DOM range
		currentRange = selection.getRangeAt(0).nativeRange;

		// Use getClientRects() so we can position near the last line of the selection
		const rects = currentRange.getClientRects();
		let finalRect: DOMRect | null = null;

		if (rects.length > 0) {
			// The very last rect in the selection
			finalRect = rects[rects.length - 1];
		} else {
			// Fallback to the overall bounding box if for some reason getClientRects() is empty
			finalRect = currentRange.getBoundingClientRect();
		}

		// If we still have nothing, bail out
		if (!finalRect) {
			menu.style.display = "none";
			return;
		}

		// Position the menu just after the final selected rectangle
		// e.g. slightly offset to the right (or below)
		const menuX = finalRect.right + window.scrollX + 5; // 5px offset
		const menuY = finalRect.top + window.scrollY;

		menu.style.left = `${menuX}px`;
		menu.style.top = `${menuY}px`;
		menu.style.display = "flex";

		// Add new listener
		outsideClickListener = (e: MouseEvent) => {
			const target = e.target as Node;
			if (!menu.contains(target)) {
				console.log("[Highlight] Click outside detected");
				menu.style.display = "none";
				window.getSelection()?.removeAllRanges();
				document.removeEventListener("mousedown", outsideClickListener!);
			}
		};

		// Toggle eraser visibility - UPDATED SECTION
		const eraser = document.getElementById("highlight-eraser");
		if (eraser && highlighter) {
			const selection = window.rangy.getSelection();
			const existing = highlighter.getHighlightsInSelection(selection);
			eraser.style.display = existing.length > 0 ? "flex" : "none";
		}
	}
	function handleOutsideClick(e: MouseEvent): void {
		console.log("handle outside click is triggered");
		const target = e.target as Node;

		// Only act if menu is currently visible
		if (menu.style.display !== "flex") return;

		// Check if click is outside the menu
		if (!menu.contains(target)) {
			console.log("[Highlight] Click outside detected, hiding menu");
			menu.style.display = "none";

			// Clear any existing selection
			window.getSelection()?.removeAllRanges();
		}
	}

	// Update the applyHighlight function
	function applyHighlight(colorName: ColorName): void {
		if (!currentRange || !highlighter || !window.rangy) return;

		const selection = window.rangy.getSelection();
		const existing = highlighter.getHighlightsInSelection(selection);

		// Check if any existing highlights in selection are the same color
		const hasSameColor = existing.some(
			(h) => h.classApplier.className === `highlight-${colorName}`
		);

		if (hasSameColor) {
			// Remove only same-color highlights within the selection
			const sameColorHighlights = existing.filter(
				(h) => h.classApplier.className === `highlight-${colorName}`
			);
			highlighter.removeHighlights(sameColorHighlights);
		} else {
			// Apply new color while preserving existing different colors
			highlighter.highlightSelection(`highlight-${colorName}`, {
				selection: selection,
				containerElementId: "highlight-root",
			});
		}

		persist();

		// Clear selection and hide menu
		window.getSelection()?.removeAllRanges();
		menu.style.display = "none";

		if (outsideClickListener) {
			document.removeEventListener("mousedown", outsideClickListener);
		}
	}

	function handleClear(): void {
		if (!highlighter || !window.rangy) return;

		const selection = window.rangy.getSelection();
		const existing = highlighter.getHighlightsInSelection(selection);
		if (existing.length > 0) {
			highlighter.removeHighlights(existing);
			persist();
		}

		// Unselect any remaining range
		window.rangy.getSelection()?.removeAllRanges();
		menu.style.display = "none";

		// Cleanup listener
		if (outsideClickListener) {
			document.removeEventListener("mousedown", outsideClickListener);
		}
	}

	function persist(): void {
		if (!highlighter) return;
		localStorage.setItem(storageKey, highlighter.serialize());
	}

	// Initialize on page load
	document.addEventListener("DOMContentLoaded", () => {
		rootElement = document.getElementById("highlight-root");
		updateDarkMode();
		document.addEventListener("themeToggled", updateDarkMode);
		initializeHighlighter();
	});
</script>
