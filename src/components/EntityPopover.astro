---
import qualities from "../data/qualities.json";
import topicMappings from "../data/topicMappings.json";
import { generateContentTagHtml } from "../utils/ContentTagUtils";
import { marked } from "marked";

interface Props {
	itemId: string;
	class?: string;
	href?: string;
}

const { itemId, class: className, href } = Astro.props;

// --- Data Resolution ---
const topicData = topicMappings[itemId as keyof typeof topicMappings];
const qData = (qualities.qualities as any)[itemId];

let title = "";
let context = "";
let synonyms: string[] = [];
let pali: string[] = [];
let types: (
	| "topic"
	| "bright-quality"
	| "negative-quality"
	| "neutral-quality"
)[] = [];

// Check if it's a topic
if (topicData) {
	title = topicData.title;
	context = topicData.description;
	synonyms = topicData.synonyms || [];
	pali = topicData.pali || [];
	types.push("topic");
}

// Check if it's also a quality (can be both topic and quality)
if (qData) {
	if (!title) {
		title = itemId.charAt(0).toUpperCase() + itemId.slice(1);
	}

	if (qualities.positive.includes(itemId)) types.push("bright-quality");
	else if (qualities.negative.includes(itemId))
		types.push("negative-quality");
	else types.push("neutral-quality");

	const lines = Array.isArray(qData) ? qData : [];
	lines.forEach((line: string) => {
		if (line.startsWith("Context:")) {
			// Only use quality context if we don't have topic description
			if (!context) {
				context = line.replace("Context:", "").trim();
			}
		} else if (line.startsWith("[")) {
			const content = line.replace(/[\[\]]/g, "");
			const paliTerms = content.split(",").map((s) => s.trim());
			// Merge pali terms, avoiding duplicates
			paliTerms.forEach((term) => {
				if (!pali.includes(term)) pali.push(term);
			});
		} else if (
			!line.includes("Supported by:") &&
			!line.includes("Leads to:") &&
			!line.includes("Related:") &&
			!line.includes("Opposite:") &&
			!line.includes("Guarded by:")
		) {
			// Merge synonyms, avoiding duplicates
			const syn = line.trim();
			if (syn && !synonyms.includes(syn)) synonyms.push(syn);
		}
	});
}

const contextHtml = context ? await marked.parseInline(context) : "";
const badgeHtmlArray = types.map((type) =>
	generateContentTagHtml(type, { tooltipPos: "bottom" })
);
---

{
	title ? (
		<div class:list={["entity-popover-wrapper", className]}>
			<div class="popover-trigger" tabindex="0">
				<slot />
			</div>

			<div class="popover-content">
				<div class="popover-header">
					<h3 class="popover-title">{title}</h3>
					<div class="popover-badges">
						{badgeHtmlArray.map((badgeHtml) => (
							<div class="popover-badge" set:html={badgeHtml} />
						))}
					</div>
				</div>

				<div class="popover-contentarea">
					{context && (
						<p class="popover-context" set:html={contextHtml} />
					)}

					{synonyms.length > 0 && (
						<div class="popover-section">
							<span class="label">Also known as: </span>
							<span class="value">{synonyms.join(", ")}</span>
						</div>
					)}

					{pali.length > 0 && (
						<div class="popover-section">
							<span class="label">Pāli: </span>
							<span class="value pali">{pali.join(", ")}</span>
						</div>
					)}
				</div>

				{href && (
					<a href={href} class="popover-link">
						View all discourses →
					</a>
				)}

				<div class="popover-arrow" />
			</div>
		</div>
	) : (
		<slot />
	)
}

<style>
	.entity-popover-wrapper {
		position: relative;
		display: inline-block;
	}

	.popover-trigger {
		cursor: help;
	}

	.popover-content {
		position: absolute;
		bottom: 100%;
		left: 50%;
		transform: translateX(-50%) translateY(-10px);
		width: 360px;
		max-width: 90vw;
		background-color: var(--surface-elevated, #ffffff);
		border: 1px solid var(--popover-border, #e5e7eb);
		border-radius: 0.5rem;
		padding: 1rem;
		box-shadow:
			0 10px 15px -3px rgba(0, 0, 0, 0.1),
			0 4px 6px -2px rgba(0, 0, 0, 0.05);
		z-index: 1000;

		/* Flex layout for header/body/footer structure */
		display: flex;
		flex-direction: column;

		/* Hidden state */
		opacity: 0;
		visibility: hidden;
		transition:
			opacity 0.2s ease,
			transform 0.2s ease,
			visibility 0.2s;
		transition-delay: 0.2s; /* Delay hiding to allow moving mouse to content */
		/* pointer-events: none; Removed to allow hovering during transition */

		/* Text styles */
		text-align: left;
		color: var(--surface-ink, #1f2937);
		font-size: 0.95rem;
		line-height: 1.5;

		/* Dynamic max-height set by JS */
		max-height: var(--popover-max-height, 400px);
	}

	/* Scrollable body section */
	.popover-contentarea {
		flex: 1;
		overflow-y: auto;
		min-height: 0; /* Allow shrinking */
		/* Subtle scroll indicator */
		scrollbar-width: thin;
		scrollbar-color: var(--gray-300, #d1d5db) transparent;
	}

	.popover-contentarea::-webkit-scrollbar {
		width: 4px;
	}

	.popover-contentarea::-webkit-scrollbar-track {
		background: transparent;
	}

	.popover-contentarea::-webkit-scrollbar-thumb {
		background-color: var(--gray-300, #d1d5db);
		border-radius: 2px;
	}

	/* Show state */
	.entity-popover-wrapper:hover .popover-content,
	.popover-trigger:focus + .popover-content,
	.popover-trigger:focus-within + .popover-content,
	.entity-popover-wrapper.is-open .popover-content {
		opacity: 1;
		visibility: visible;
		transform: translateX(-50%) translateY(-5px); /* Slide up slightly */
		transition-delay: 0s; /* Show immediately */
	}

	/* Invisible bridge to prevent closing when moving mouse between trigger and content */
	.popover-content::before {
		content: "";
		position: absolute;
		top: 100%;
		left: 0;
		width: 100%;
		height: 15px;
		background: transparent;
	}

	/* Arrow */
	.popover-arrow {
		position: absolute;
		top: 100%;
		left: 50%;
		margin-left: -6px;
		border-width: 6px;
		border-style: solid;
		border-color: var(--surface-elevated, #ffffff) transparent transparent
			transparent;
		/* Add a border shadow effect if needed, but simple is better for now */
		filter: drop-shadow(0 1px 0 var(--popover-border, #e5e7eb));
	}

	/* Content Styling */
	.popover-header {
		display: flex;
		align-items: center;
		justify-content: space-between;
		gap: 0.1rem;
		margin-bottom: 0.75rem;
		border-bottom: 1px solid var(--surface-border, #f3f4f6);
		padding-bottom: 0.5rem;
	}

	.popover-title {
		font-family: "Crimson Pro", serif;
		font-size: 1.25rem;
		font-weight: 600;
		margin: 0;
		color: var(--surface-ink, #111827);
		line-height: 1.2;
	}

	.popover-badge {
		flex-shrink: 0;
	}

	.popover-badges {
		display: flex;
		gap: 0.25rem;
		flex-shrink: 0;
	}

	.popover-context {
		margin-bottom: 0.75rem;
		color: var(--text-color, #374151);
	}

	.popover-context :global(a) {
		color: var(--color-primary, #d97706);
		text-decoration: underline;
	}

	.popover-context :global(a:hover) {
		text-decoration: none;
	}

	.popover-section {
		font-size: 0.85rem;
		margin-top: 0.75rem;
	}

	.label {
		color: var(--text-muted, #9ca3af);
	}

	.value {
		color: var(--surface-ink, #1f2937);
	}

	.value.pali {
		font-style: italic;
	}

	.popover-link {
		display: block;
		margin-top: 0.75rem;
		padding-top: 0.5rem;
		border-top: 1px solid var(--surface-border, #f3f4f6);
		font-size: 0.85rem;
		color: var(--color-primary, #d97706);
		text-decoration: none;
		text-align: right;
	}

	.popover-link:hover {
		text-decoration: underline;
	}

	/* Dynamic Positioning Classes (applied by JS) */
	.popover-content.opens-down {
		bottom: auto;
		top: 100%;
		transform: translateX(calc(-50% + var(--x-offset, 0px)))
			translateY(10px);
	}

	.popover-content.opens-down::before {
		top: auto;
		bottom: 100%;
	}

	.entity-popover-wrapper:hover .popover-content.opens-down,
	.popover-trigger:focus + .popover-content.opens-down,
	.popover-trigger:focus-within + .popover-content.opens-down,
	.entity-popover-wrapper.is-open .popover-content.opens-down {
		transform: translateX(calc(-50% + var(--x-offset, 0px))) translateY(5px);
	}

	/* Arrow adjustment for opens-down */
	.popover-content.opens-down .popover-arrow {
		top: auto;
		bottom: 100%;
		border-color: transparent transparent var(--surface-elevated, #ffffff)
			transparent;
		filter: drop-shadow(0 -1px 0 var(--popover-border, #e5e7eb));
	}

	/* Apply horizontal offset if set */
	.popover-content[style*="--x-offset"] {
		transform: translateX(calc(-50% + var(--x-offset, 0px)))
			translateY(-10px);
	}

	.entity-popover-wrapper:hover .popover-content[style*="--x-offset"],
	.popover-trigger:focus + .popover-content[style*="--x-offset"],
	.popover-trigger:focus-within + .popover-content[style*="--x-offset"],
	.entity-popover-wrapper.is-open .popover-content[style*="--x-offset"] {
		transform: translateX(calc(-50% + var(--x-offset, 0px)))
			translateY(-5px);
	}
</style>

<script>
	// Defensive positioning logic and touch handling
	function setupPopovers() {
		const wrappers = document.querySelectorAll(".entity-popover-wrapper");
		let activePopover: HTMLElement | null = null;

		// Close any open popover when tapping outside
		function closeActivePopover() {
			if (activePopover) {
				activePopover.classList.remove("is-open");
				activePopover = null;
			}
		}

		document.addEventListener("click", (e) => {
			const target = e.target as HTMLElement;
			// If click is outside any popover wrapper, close active
			if (!target.closest(".entity-popover-wrapper")) {
				closeActivePopover();
			}
		});

		wrappers.forEach((wrapper) => {
			const trigger = wrapper.querySelector(
				".popover-trigger"
			) as HTMLElement;
			const content = wrapper.querySelector(
				".popover-content"
			) as HTMLElement;

			if (!trigger || !content) return;

			const updatePosition = () => {
				const triggerRect = trigger.getBoundingClientRect();
				const contentWidth = content.offsetWidth || 360;

				// Vertical Check
				const spaceAbove = triggerRect.top;
				const spaceBelow = window.innerHeight - triggerRect.bottom;

				// Minimum threshold: only flip to bottom if space above is really small
				// Header (~50px) + some body content (~80px) + footer (~40px) + padding (~30px) = ~200px min
				const minThreshold = 150;

				// Prefer opening above (top) for consistency
				// Only open below if space above is below minimum threshold
				let shouldOpenDown = false;

				if (spaceAbove >= minThreshold) {
					// Enough space above - open on top with scrollable body if needed
					shouldOpenDown = false;
				} else if (spaceBelow > spaceAbove) {
					// Not enough space above, and more space below
					shouldOpenDown = true;
				} else {
					// Both cramped, prefer top
					shouldOpenDown = false;
				}

				if (shouldOpenDown) {
					content.classList.add("opens-down");
					// Set max-height based on available space below
					const maxHeight = Math.min(spaceBelow - 20, 400);
					content.style.setProperty(
						"--popover-max-height",
						`${maxHeight}px`
					);
				} else {
					content.classList.remove("opens-down");
					// Set max-height based on available space above
					const maxHeight = Math.min(spaceAbove - 20, 400);
					content.style.setProperty(
						"--popover-max-height",
						`${maxHeight}px`
					);
				}

				// Horizontal Check
				const viewportWidth = window.innerWidth;
				const centerX = triggerRect.left + triggerRect.width / 2;
				const halfWidth = contentWidth / 2;

				let xOffset = 0;

				if (centerX - halfWidth < 10) {
					// Clips left
					xOffset = 10 - (centerX - halfWidth);
				} else if (centerX + halfWidth > viewportWidth - 10) {
					// Clips right
					xOffset = viewportWidth - 10 - (centerX + halfWidth);
				}

				if (xOffset !== 0) {
					content.style.setProperty("--x-offset", `${xOffset}px`);
				} else {
					content.style.removeProperty("--x-offset");
				}
			};

			// Touch handling: toggle popover on tap
			trigger.addEventListener("click", (e) => {
				// Check if we're on a touch device (no hover capability)
				const isTouchDevice =
					window.matchMedia("(hover: none)").matches;

				if (isTouchDevice) {
					e.preventDefault();
					e.stopPropagation();

					const isCurrentlyOpen =
						wrapper.classList.contains("is-open");

					// Close any other open popover
					closeActivePopover();

					if (!isCurrentlyOpen) {
						updatePosition();
						wrapper.classList.add("is-open");
						activePopover = wrapper as HTMLElement;
					}
				}
			});

			trigger.addEventListener("mouseenter", updatePosition);
			trigger.addEventListener("focus", updatePosition);
		});
	}

	// Run on load and after Astro swaps
	setupPopovers();
	document.addEventListener("astro:page-load", setupPopovers);
</script>
